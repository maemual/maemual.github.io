<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>0x01</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://0x01.io/"/>
  <updated>2020-05-28T04:41:33.625Z</updated>
  <id>https://0x01.io/</id>
  
  <author>
    <name>maemual</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《The Effective Engineer》读书摘要</title>
    <link href="https://0x01.io/2020/05/28/%E3%80%8AThe-Effective-Engineer%E3%80%8B%E8%AF%BB%E4%B9%A6%E6%91%98%E8%A6%81/"/>
    <id>https://0x01.io/2020/05/28/%E3%80%8AThe-Effective-Engineer%E3%80%8B%E8%AF%BB%E4%B9%A6%E6%91%98%E8%A6%81/</id>
    <published>2020-05-28T12:33:10.000Z</published>
    <updated>2020-05-28T04:41:33.625Z</updated>
    
    <content type="html"><![CDATA[<p>高效的工程师是那些被认为可以把事情搞定的人。同时，是可以高效率的把事情搞定的人。</p><p>高效工程师聚焦在价值和影响力上。</p><h2 id="Part-1-Adopt-the-Right-Mindsets"><a href="#Part-1-Adopt-the-Right-Mindsets" class="headerlink" title="Part 1: Adopt the Right Mindsets"></a>Part 1: Adopt the Right Mindsets</h2><h3 id="Focus-on-High-Leverage-Activities"><a href="#Focus-on-High-Leverage-Activities" class="headerlink" title="Focus on High-Leverage Activities"></a>Focus on High-Leverage Activities</h3><h4 id="Use-Leverage-as-Your-Yardstick-for-Effectiveness"><a href="#Use-Leverage-as-Your-Yardstick-for-Effectiveness" class="headerlink" title="Use Leverage as Your Yardstick for Effectiveness"></a>Use Leverage as Your Yardstick for Effectiveness</h4><p>杠杆率 = 产出 / 时间</p><p>简单的说就是 ROI，投入产出比。</p><p>时间是最宝贵的资源。</p><a id="more"></a><h4 id="Increase-Your-Leverage-in-Three-Ways"><a href="#Increase-Your-Leverage-in-Three-Ways" class="headerlink" title="Increase Your Leverage in Three Ways"></a>Increase Your Leverage in Three Ways</h4><p>提高杠杆率的三个途径：</p><ul><li>减少做某件事的时间</li></ul><ul><li>增加做某件事的产出</li><li>换到有更高杠杆率的事情上去</li></ul><p>翻译成三个问题：</p><ul><li>如何缩短完成这件事情的时间？</li></ul><ul><li>如何提高这件事情的产出价值？</li><li>有什么值得花费我时间的事情可以产出更多的价值？</li></ul><h4 id="Direct-Energy-Toward-Leverage-Points-Not-Just-Easy-Wins"><a href="#Direct-Energy-Toward-Leverage-Points-Not-Just-Easy-Wins" class="headerlink" title="Direct Energy Toward Leverage Points, Not Just Easy Wins"></a>Direct Energy Toward Leverage Points, Not Just Easy Wins</h4><p><em>聚焦于高杠杆率的事情</em></p><h4 id="Key-Takeaways"><a href="#Key-Takeaways" class="headerlink" title="Key Takeaways"></a>Key Takeaways</h4><ul><li>使用杠杆率来评价你的工程效率</li></ul><ul><li>有条理的提升你时间的杠杆率</li><li>集中关注在支点上</li></ul><h3 id="Optimize-for-Learning"><a href="#Optimize-for-Learning" class="headerlink" title="Optimize for Learning"></a>Optimize for Learning</h3><p>持续优化学习是高效工程师的一项非常高杠杆的活动</p><h4 id="Adopt-a-Growth-Mindset"><a href="#Adopt-a-Growth-Mindset" class="headerlink" title="Adopt a Growth Mindset"></a>Adopt a Growth Mindset</h4><p>拥抱成长性思维，意味着对你可以改变的各个方面都承担责任，而不是将失败和缺点都归咎于你无法掌控的事情。</p><h4 id="Invest-in-Your-Rate-of-Learning"><a href="#Invest-in-Your-Rate-of-Learning" class="headerlink" title="Invest in Your Rate of Learning"></a>Invest in Your Rate of Learning</h4><ul><li>学习也遵循指数增长曲线</li></ul><ul><li>越早优化学习，可以享受越久的复利</li><li>微小的差异在长期未来也能产生巨大的差别</li></ul><p>把自己当作是创业或 beta 版的产品，需要每天不断的投资、迭代</p><h4 id="Seek-Work-Environments-Conducive-to-Learning"><a href="#Seek-Work-Environments-Conducive-to-Learning" class="headerlink" title="Seek Work Environments Conducive to Learning"></a>Seek Work Environments Conducive to Learning</h4><p>寻求有利于学习的工作环境</p><p>寻找公司或者团队的六个因素：</p><ul><li>快速成长</li></ul><ul><li>培训</li><li>开放</li><li>节奏</li><li>人</li><li>自主性</li></ul><h4 id="Dedicate-Time-on-the-Job-to-Develop-New-Skills"><a href="#Dedicate-Time-on-the-Job-to-Develop-New-Skills" class="headerlink" title="Dedicate Time on the Job to Develop New Skills"></a>Dedicate Time on the Job to Develop New Skills</h4><p>在工作中花时间发展新技能</p><p>每天花 1-2 小时整块时间。对你长期未来能够更加高效投资。</p><p>可以对你工作的领域或者使用的工具有着更深刻的理解。</p><p>也可以获得临近学科的经验。（工作上下游相关其他工种的知识经验）</p><p>十条建议：</p><ul><li>学习公司内最好的工程师的核心抽象代码。特别是在大型公司。</li></ul><ul><li>写更多的代码。针对提高编码能力，和阅读代码相比，练习是更高杠杆率的活动。</li><li>浏览内部提供的技术或者教育材料。</li><li>掌握你所使用的编程语言。</li><li>将代码发送给最严格的批评家评审。</li><li>在要改进的地方学习。</li><li>参加你感兴趣的项目设计讨论会。</li><li>从事各种各样的项目。</li><li>确保你所在的团队里，至少还有几个你可以向他们学习的工程师。</li><li>毫不畏惧的跳入你不懂的代码中。</li></ul><h4 id="Always-Be-Learning"><a href="#Always-Be-Learning" class="headerlink" title="Always Be Learning"></a>Always Be Learning</h4><p>持续不算的学习</p><p>学习的机会并不局限于工作场所。其他技能也值得学习。</p><p>学什么：</p><ul><li>学习新的编程语言和框架。</li></ul><ul><li>在当前高需求的技能上投资。</li><li>读书。</li><li>加入一个讨论组。</li><li>参加一些技术会议、讲座等。</li><li>建立并维系一些强有力的关系网。</li><li>关注一些技术博客。</li><li>写一些东西。</li><li>做一些业余项目。</li><li>追寻你所热爱的事情。</li></ul><h4 id="Key-Takeawsys"><a href="#Key-Takeawsys" class="headerlink" title="Key Takeawsys"></a>Key Takeawsys</h4><ul><li>为自己负责</li></ul><ul><li>不要降低学习速度</li><li>寻找可以持续成长的工作环境</li><li>利用工作机会提高技术技能</li><li>在工作场所之外学习</li></ul><h3 id="Prioritize-Regularly"><a href="#Prioritize-Regularly" class="headerlink" title="Prioritize Regularly"></a>Prioritize Regularly</h3><p>规律性的制定优先级</p><h4 id="Track-To-Dos-in-a-Single-Easily-Accessible-List"><a href="#Track-To-Dos-in-a-Single-Easily-Accessible-List" class="headerlink" title="Track To-Dos in a Single, Easily Accessible List"></a>Track To-Dos in a Single, Easily Accessible List</h4><p>跟踪所有的 TO-DO 在一个单一、容易找到的列表里</p><p>关注于当前立即可以产生价值的，和重要不紧急的。</p><h4 id="Focus-on-What-Directly-Produces-Value"><a href="#Focus-on-What-Directly-Produces-Value" class="headerlink" title="Focus on What Directly Produces Value"></a>Focus on What Directly Produces Value</h4><p>关注当下可以立即产生价值的事情</p><p>公司关注的是你创造的价值。价值例如产品推进，用户获取，销售额等，而不是开了多少会、写了多少代码。</p><h4 id="Focus-on-the-Important-and-Non-Urgent"><a href="#Focus-on-the-Important-and-Non-Urgent" class="headerlink" title="Focus on the Important and Non-Urgent"></a>Focus on the Important and Non-Urgent</h4><p>关注重要但不紧急的事情。</p><p>我们每天都被紧急的事情淹没：开会、邮件、电话、bug、DDL。其中有些是重要的，有些并不是。</p><p>重要、紧急：高优问题、DDL 等<br>不重要、紧急：大多数的 email、电话、会议<br>重要、不紧急：职业生涯规划、建立了强人际关系、读书、建立新的高效习惯、构建工具以改善工作流、学习新的语言等等</p><h4 id="Protect-Your-Maker’s-Schedule"><a href="#Protect-Your-Maker’s-Schedule" class="headerlink" title="Protect Your Maker’s Schedule"></a>Protect Your Maker’s Schedule</h4><p>保护你的时间表。</p><p>和其他专业工作相比，软件工程师需要更多长、持续的时间段来提高工作效率。</p><p>尽可能的将会议安排在连续的时间段或者一天的早晚，而不是分散这些会议。</p><h4 id="Limit-the-Amount-of-Work-in-Progress"><a href="#Limit-the-Amount-of-Work-in-Progress" class="headerlink" title="Limit the Amount of Work in Progress"></a>Limit the Amount of Work in Progress</h4><p>限制同时在进行中的项目数量。</p><p>人脑的并发处理能力非常有限。</p><h4 id="Fight-Procrastination-with-If-Then-Plans"><a href="#Fight-Procrastination-with-If-Then-Plans" class="headerlink" title="Fight Procrastination with If-Then Plans"></a>Fight Procrastination with If-Then Plans</h4><p>通过 if-then 计划来避免拖延。</p><p>例如，收集一系列的 20 分钟内可以完成的短任务，如代码评审、写面试反馈、回邮件、调查小 bug、写测试等。</p><h4 id="Make-a-Routine-of-Prioritization"><a href="#Make-a-Routine-of-Prioritization" class="headerlink" title="Make a Routine of Prioritization"></a>Make a Routine of Prioritization</h4><p>制定优先顺序。</p><p>养成重新回顾这些优先计划的习惯。</p><h4 id="Key-Takeaways-1"><a href="#Key-Takeaways-1" class="headerlink" title="Key Takeaways"></a>Key Takeaways</h4><ul><li>写下并 review to-dos</li></ul><ul><li>做有直接价值的事情</li><li>做重要但是不紧急的事情</li><li>减少上下文切换</li><li>使用 if-then 计划和拖延作斗争</li><li>养成制定优先级的习惯</li></ul><h2 id="Part-2-Execute-Execute-Execute"><a href="#Part-2-Execute-Execute-Execute" class="headerlink" title="Part 2: Execute, Execute, Execute"></a>Part 2: Execute, Execute, Execute</h2><h3 id="Invest-in-Iteration-Speed"><a href="#Invest-in-Iteration-Speed" class="headerlink" title="Invest in Iteration Speed"></a>Invest in Iteration Speed</h3><p>高效工程师在迭代速度上进行大量的投资。</p><h4 id="Move-Fast-to-Learn-Fast"><a href="#Move-Fast-to-Learn-Fast" class="headerlink" title="Move Fast to Learn Fast"></a>Move Fast to Learn Fast</h4><p>迭代的越快，你能越快的知道这些工作是否有效。</p><p>持续部署是提供给你用于加快迭代速度的有力工具之一</p><h4 id="Invest-in-Time-Saving-Tools"><a href="#Invest-in-Time-Saving-Tools" class="headerlink" title="Invest in Time-Saving Tools"></a>Invest in Time-Saving Tools</h4><p>节省时间的工具可以带来丰厚的回报。</p><p>更快的工具会被使用的更多。</p><p>值得花费一些努力去寻找一个更平滑的方式以便降低从现有工作流切换到新的工具的成本。</p><h4 id="Shorten-Your-Debugging-and-Validation-Loops"><a href="#Shorten-Your-Debugging-and-Validation-Loops" class="headerlink" title="Shorten Your Debugging and Validation Loops"></a>Shorten Your Debugging and Validation Loops</h4><p>缩短调试和验证的时间周期。</p><p>下一次，当你修复一个 bug 或者迭代一个新的 feature，发现自己又在重复进行同样的行为的时候，停下来。想一想，你是否可以缩短这个时间周期。</p><h4 id="Master-Your-Programming-Environment"><a href="#Master-Your-Programming-Environment" class="headerlink" title="Master Your Programming Environment"></a>Master Your Programming Environment</h4><p>熟练你的编程环境。</p><ul><li>在版本控制里跟踪变更</li></ul><ul><li>编译、构建代码</li><li>跑单元测试</li><li>重启开发中的 Web Server</li><li>测试一个表达式的行为</li><li>查找文档</li><li>跳到函数定义</li><li>在文本编辑器里重新格式化代码或者数据</li><li>找到函数的调用方</li><li>重新排列桌面窗口</li><li>导航到文件的特定位置</li></ul><p>入手点：</p><ul><li>熟练你喜欢的文本编辑器或者 IDE：Emacs、VIM or something else</li></ul><ul><li>学习至少一个高产、高级的编程语言：Python、Ruby</li><li>熟悉 UNIX 或者 Windows 的 shell 命令：grep、sort、uniq、wc、awk、sed、xargs、find</li><li>更加习惯于使用键盘而不是鼠标</li><li>自动化你的手工操作</li><li>使用交互式解释器来测试自己的想法：Python、Ruby、JavaScript</li><li>使运行单元测试尽可能的快和简单</li></ul><h4 id="Don’t-Ignore-Your-Non-Engineering-Bottlenecks"><a href="#Don’t-Ignore-Your-Non-Engineering-Bottlenecks" class="headerlink" title="Don’t Ignore Your Non-Engineering Bottlenecks"></a>Don’t Ignore Your Non-Engineering Bottlenecks</h4><p>不要忽视你的非工程的瓶颈</p><p>优化迭代速度的最佳策略和优化系统性能一样：找出最大的瓶颈，然后解决它们。</p><p>高效工程师会找出并处理这些最大的瓶颈，尽管可能这些瓶颈并不涉及到写代码或者不在他们的舒适区内。</p><p>一个常见的瓶颈就是对其他人工作的依赖。</p><p>沟通对于推进与人相关的瓶颈点至关重要。</p><p>另一个常见的瓶颈类型是获得关键决策者的批准。</p><p>第三种瓶颈是项目启动之后的审查流程。</p><p>在大公司，解决这些瓶颈可能超出了你的影响范围，而你能做的最好的事情是围绕它们开展工作。在小的初创公司，你通常都可以直接解决瓶颈本身。</p><h4 id="Key-Takeways"><a href="#Key-Takeways" class="headerlink" title="Key Takeways"></a>Key Takeways</h4><ul><li>迭代的越快，学的越多</li></ul><ul><li>在工具化上投资</li><li>优化你的 debug 工作流</li><li>掌握你手艺的基础</li><li>全面了解你的迭代循环</li></ul><h3 id="Measure-What-You-Want-to-Improve"><a href="#Measure-What-You-Want-to-Improve" class="headerlink" title="Measure What You Want to Improve"></a>Measure What You Want to Improve</h3><p>衡量你要改进的地方</p><h4 id="Use-Metrics-to-Drive-Progress"><a href="#Use-Metrics-to-Drive-Progress" class="headerlink" title="Use Metrics to Drive Progress"></a>Use Metrics to Drive Progress</h4><p>使用指标来驱动进步</p><p>如果你不能衡量它，你就不能改进它。</p><ul><li>好的指标可以实现许多目标</li></ul><ul><li>当随着时间的推移而可视化时，好的指标有助于防止将来的回归。</li><li>好的指标可以推动进步</li><li>一个好的指标可以让您衡量一段时间内的效果，并将你正在做的事情与可能要进行的其他活动进行比较</li></ul><p>很难衡量目标并不意味着不值得做。</p><h4 id="Pick-the-Right-Metric-to-Incentivize-the-Behavior-You-Want"><a href="#Pick-the-Right-Metric-to-Incentivize-the-Behavior-You-Want" class="headerlink" title="Pick the Right Metric to Incentivize the Behavior You Want"></a>Pick the Right Metric to Incentivize the Behavior You Want</h4><p>挑选正确的指标来激励你想要的行为</p><p>指标选择：</p><ol><li>最大化影响</li><li>可行动的</li><li>反应迅速同时健壮</li></ol><h4 id="Instrument-Everything-to-Understand-What’s-Going-On"><a href="#Instrument-Everything-to-Understand-What’s-Going-On" class="headerlink" title="Instrument Everything to Understand What’s Going On"></a>Instrument Everything to Understand What’s Going On</h4><p>监控一切以便理解到底发生什么</p><h4 id="Internalize-Useful-Numbers"><a href="#Internalize-Useful-Numbers" class="headerlink" title="Internalize Useful Numbers"></a>Internalize Useful Numbers</h4><p>内部化有用的数字还可以帮助您发现数据测量中的异常</p><p>了解有用的数字可以明确改进的领域和范围</p><p>有用的数字：</p><ul><li>注册用户数、日活、月活</li></ul><ul><li>每秒请求数</li><li>数据存储容量上限</li><li>每天读写数据量</li><li>支持一个特定服务需要的服务器数量</li><li>不同的服务的吞吐量</li><li>流量的增长率</li><li>页面平均加载时长</li><li>产品不同部分之间的流量分布</li><li>不同的 Web 浏览器、移动设备、操作系统的流量分布</li></ul><h4 id="Be-Skeptical-about-Data-Integrity"><a href="#Be-Skeptical-about-Data-Integrity" class="headerlink" title="Be Skeptical about Data Integrity"></a>Be Skeptical about Data Integrity</h4><p>对数据完整性保持着怀疑态度</p><p>有时候会混淆相关性和因果关系</p><h4 id="Key-Takeaways-2"><a href="#Key-Takeaways-2" class="headerlink" title="Key Takeaways"></a>Key Takeaways</h4><ul><li>衡量进度</li></ul><ul><li>小心的选择最高层的指标</li><li>监控你的系统</li><li>知道你的数据</li><li>优先考虑数据完整性</li></ul><h3 id="Validate-Your-Ideas-Early-and-Often"><a href="#Validate-Your-Ideas-Early-and-Often" class="headerlink" title="Validate Your Ideas Early and Often"></a>Validate Your Ideas Early and Often</h3><p>尽早并且经常性的验证你的想法</p><p>尽快根据用户反馈来优化</p><p>尽早并经常验证我们的想法有助于我们完成正确的事情</p><h4 id="Find-Low-Effort-Ways-to-Validate-Your-Work"><a href="#Find-Low-Effort-Ways-to-Validate-Your-Work" class="headerlink" title="Find Low-Effort Ways to Validate Your Work"></a>Find Low-Effort Ways to Validate Your Work</h4><p>找到低成本的方式来验证你的工作</p><p>一个可行的验证想法的方式是花 10% 的投入构建一个小而又足够信息的原型</p><h4 id="Continuously-Validate-Product-Changes-with-A-B-Testing"><a href="#Continuously-Validate-Product-Changes-with-A-B-Testing" class="headerlink" title="Continuously Validate Product Changes with A/B Testing"></a>Continuously Validate Product Changes with A/B Testing</h4><p>持续通过 A/B 测试来验证产品变更</p><h4 id="Beware-the-One-Person-Team"><a href="#Beware-the-One-Person-Team" class="headerlink" title="Beware the One-Person Team"></a>Beware the One-Person Team</h4><p>当心一人团队</p><p>建立有效的反馈渠道：</p><ul><li>保持开放，乐于接受反馈</li></ul><ul><li>尽早经常的提交代码评审</li><li>请求最严格的评审者来评审代码</li><li>询问同事的想法看法</li><li>先设计系统的接口和 API</li><li>投入编码前先展示你的设计文档</li><li>如果可能，请对正在进行的项目进行结构设计，以便与队友共享一些上下文</li><li>在投入太多时间之前，对有争议的问题寻求讨论和支持</li></ul><h4 id="Build-Feedback-Loops-for-Your-Decisions"><a href="#Build-Feedback-Loops-for-Your-Decisions" class="headerlink" title="Build Feedback Loops for Your Decisions"></a>Build Feedback Loops for Your Decisions</h4><p>建立你的决定反馈循环</p><p>设计实验验证你的猜想，不论好坏，从实验结果中学习</p><h4 id="Key-Takeaways-3"><a href="#Key-Takeaways-3" class="headerlink" title="Key Takeaways"></a>Key Takeaways</h4><ul><li>迭代的去处理问题，以避免浪费投入</li></ul><ul><li>将大的实现拆分成小模块验证以降低风险</li><li>使用 A/B 测试来持续的验证你的产品假设</li><li>当工作在一个独立项目中时，寻求一个定期的外部反馈</li><li>采取积极的态度去验证你的决定</li></ul><h3 id="Improve-Your-Project-Estimation-Skills"><a href="#Improve-Your-Project-Estimation-Skills" class="headerlink" title="Improve Your Project Estimation Skills"></a>Improve Your Project Estimation Skills</h3><p>项目估期是高效工程师需要学习的最难的技能之一。</p><h4 id="Use-Accurate-Estimates-to-Drive-Project-Planning"><a href="#Use-Accurate-Estimates-to-Drive-Project-Planning" class="headerlink" title="Use Accurate Estimates to Drive Project Planning"></a>Use Accurate Estimates to Drive Project Planning</h4><p>使用准确的估期来驱动项目计划</p><p>一些策略：</p><ul><li>拆分项目成小的任务</li></ul><ul><li>估期建立在任务需要多久完成，而不是你或者其他人希望多久完成</li><li>将估期视为概率分布，而不是最佳情况</li><li>让实际做这项工作的人来估期</li><li>当心锚定偏差</li><li>使用多种方式来估计同样的任务</li><li>警惕神话般的人月：加人缩短不了工期</li><li>通过历史数据来验证估期</li><li>使用时间盒子来限制任务的增长</li><li>允许别人挑战你的估期</li></ul><h4 id="Budget-for-the-Unknown"><a href="#Budget-for-the-Unknown" class="headerlink" title="Budget for the Unknown"></a>Budget for the Unknown</h4><p>给未知事物留下缓冲预算</p><h4 id="Define-Specific-Project-Goals-and-Measurable-Milestones"><a href="#Define-Specific-Project-Goals-and-Measurable-Milestones" class="headerlink" title="Define Specific Project Goals and Measurable Milestones"></a>Define Specific Project Goals and Measurable Milestones</h4><p>设定明确的项目目标和可衡量的里程碑</p><p>明确定义的目标提供了一个重要的过滤器，用于将任务列表中的必须有与最好有分开</p><p>定义特定项目目标的第二个好处是，它可以在关键利益相关者之间建立清晰度和一致性。</p><h4 id="Reduce-Risk-Early"><a href="#Reduce-Risk-Early" class="headerlink" title="Reduce Risk Early"></a>Reduce Risk Early</h4><p>尽早暴露并降低风险</p><p>如何降低集成风险？尽早做端到端的脚手架和系统整合测试。</p><h4 id="Approach-Rewrite-Projects-with-Extreme-Caution"><a href="#Approach-Rewrite-Projects-with-Extreme-Caution" class="headerlink" title="Approach Rewrite Projects with Extreme Caution"></a>Approach Rewrite Projects with Extreme Caution</h4><p>极其谨慎的重写项目</p><p>有重写经验的工程师，倾向于把大的项目重写分解成一系列的小项目。</p><h4 id="Don’t-Sprint-in-the-Middle-of-a-Marathon"><a href="#Don’t-Sprint-in-the-Middle-of-a-Marathon" class="headerlink" title="Don’t Sprint in the Middle of a Marathon"></a>Don’t Sprint in the Middle of a Marathon</h4><p>不要在马拉松比赛中冲刺</p><ul><li>工作时长增加，每小时工作效率降低</li></ul><ul><li>和你想象的相比，你可能比计划表落后的更多</li><li>额外的工作会压垮团队成员</li><li>增加工作时长会伤害成员的工作热情</li><li>随着截止日期的临近，沟通的开销会增加</li><li>最后冲刺会产生大量的技术债</li></ul><p>当延期时：</p><ul><li>确保每个人都了解造成时间表迄今延误的主要原因</li></ul><ul><li>重新制定现实的时间表</li><li>如果距离重新修订的时间表很远，随时准备放弃冲刺</li></ul><h4 id="Key-Takeaways-4"><a href="#Key-Takeaways-4" class="headerlink" title="Key Takeaways"></a>Key Takeaways</h4><ul><li>将估期纳入到项目计划中</li></ul><ul><li>项目表中流出缓冲时间</li><li>定义可衡量的里程碑</li><li>先做风险大的任务</li><li>明确加班的局限性</li></ul><h2 id="Part-3-Build-Long-Term-Value"><a href="#Part-3-Build-Long-Term-Value" class="headerlink" title="Part 3: Build Long-Term Value"></a>Part 3: Build Long-Term Value</h2><h3 id="Balance-Quality-with-Pragmatism"><a href="#Balance-Quality-with-Pragmatism" class="headerlink" title="Balance Quality with Pragmatism"></a>Balance Quality with Pragmatism</h3><p>务实兼顾质量</p><h4 id="Establish-a-Sustainable-Code-Review-Process"><a href="#Establish-a-Sustainable-Code-Review-Process" class="headerlink" title="Establish a Sustainable Code Review Process"></a>Establish a Sustainable Code Review Process</h4><p>建立可持续的代码评审流程</p><p>好处：</p><ul><li>尽早发现 bug 和设计缺陷</li><li>增加对代码变更的责任心</li><li>建立正面的如何写好代码的样例</li><li>共享知识</li><li>提升长期的敏捷度</li></ul><h4 id="Manage-Complexity-through-Abstraction"><a href="#Manage-Complexity-through-Abstraction" class="headerlink" title="Manage Complexity through Abstraction"></a>Manage Complexity through Abstraction</h4><p>通过抽象来管理复杂度</p><ul><li>通过降低原始问题的复杂度变成一个简单容易理解的问题</li><li>降低未来的维护成本并且更加容易后续功能迭代</li><li>解决一个复杂的问题一次，未来就可以使用很多次</li></ul><p>好的抽象应该是：</p><ul><li>容易学习</li><li>在没有文档的情况下依然容易使用</li><li>很难误用、用错</li><li>足够强大以满足需求</li><li>容易扩展</li><li>对使用者很合适</li></ul><h4 id="Automate-Testing"><a href="#Automate-Testing" class="headerlink" title="Automate Testing"></a>Automate Testing</h4><p>自动化测试</p><h4 id="Repay-Technical-Debt"><a href="#Repay-Technical-Debt" class="headerlink" title="Repay Technical Debt"></a>Repay Technical Debt</h4><p>偿还技术债</p><p>技术债不会只是在我们做快速、肮脏的变通工作时才会积累起来。每当我们在不完全了解问题空间的情况下编写软件时，我们的第一个版本最终都可能设计得不如我们所希望的那么干净。</p><p>成为一个高效工程师的关键是在面临 DDL 的时候，可以引入一定的技术债，但同时也会周期性的偿还技术债。</p><p>高效工程师花费有限的时间以最高的杠杆率偿还债务——代码库中人流密集的部分中花费最少的时间进行修复。</p><h4 id="Key-Takeaways-5"><a href="#Key-Takeaways-5" class="headerlink" title="Key Takeaways"></a>Key Takeaways</h4><ul><li>建立代码 review 的文化</li><li>在好的软件抽象上投入以简化困难的问题</li><li>通过自动化测试提高代码质量</li><li>管理你的技术债</li></ul><h3 id="Minimize-Operational-Burden"><a href="#Minimize-Operational-Burden" class="headerlink" title="Minimize Operational Burden"></a>Minimize Operational Burden</h3><h4 id="Embrace-Operational-Simplicity"><a href="#Embrace-Operational-Simplicity" class="headerlink" title="Embrace Operational Simplicity"></a>Embrace Operational Simplicity</h4><p>高效工程师关注于简单性上。</p><p>拥有复杂架构设施带来一系列的维护问题：</p><ul><li>工程师的专长经验被分散到多个系统上</li><li>复杂性带来潜在人员的单点故障问题</li><li>新成员面临着陡峭的学习曲线</li><li>投入到提升抽象程度、库和工具的资源被分散到不同的系统上</li></ul><p>可以解决我们的问题并且可以降低未来的维护成本的方案是什么？</p><h4 id="Build-Systems-to-Fail-Fast"><a href="#Build-Systems-to-Fail-Fast" class="headerlink" title="Build Systems to Fail Fast"></a>Build Systems to Fail Fast</h4><p>快速失败</p><p>快速失败并不意味着让程序给终端用户崩溃。可以用全局的异常处理，快速上报这些错误，但优雅的给普通用户异常降级处理。</p><h4 id="Relentlessly-Automate-Mechanical-Tasks"><a href="#Relentlessly-Automate-Mechanical-Tasks" class="headerlink" title="Relentlessly Automate Mechanical Tasks"></a>Relentlessly Automate Mechanical Tasks</h4><p>无情的自动化机械任务</p><p>每次你做了某些机器可以完成的工作，问问自己是否值得自动化这些工作。</p><h4 id="Make-Batch-Processes-Idempotent"><a href="#Make-Batch-Processes-Idempotent" class="headerlink" title="Make Batch Processes Idempotent"></a>Make Batch Processes Idempotent</h4><p>让批处理任务保持幂等性</p><p>无副作用，可重试</p><h4 id="Hone-Your-Ability-to-Respond-and-Recover-Quickly"><a href="#Hone-Your-Ability-to-Respond-and-Recover-Quickly" class="headerlink" title="Hone Your Ability to Respond and Recover Quickly"></a>Hone Your Ability to Respond and Recover Quickly</h4><p>磨练你的快速响应和恢复的能力</p><p>针对主要的故障，最有效的防御措施就是经常失败。</p><p>建立快速恢复的能力。</p><p>将时间和精力集中在我们的快速恢复能力上，比起一开始就预防失败，具有更高的杠杆作用。</p><h4 id="Key-Takeaways-6"><a href="#Key-Takeaways-6" class="headerlink" title="Key Takeaways"></a>Key Takeaways</h4><ul><li>先做简单的事情</li><li>快速失败以便快速找到问题的根源</li><li>使决策过程自动化</li><li>旨在实现幂等和可重试</li><li>计划和练习失败模式</li></ul><h3 id="Invest-in-Your-Team’s-Growth"><a href="#Invest-in-Your-Team’s-Growth" class="headerlink" title="Invest in Your Team’s Growth"></a>Invest in Your Team’s Growth</h3><p>但是，如果您想提高效率，那么重要的是要认识到，建立一支强大的团队和积极的文化具有相当大的影响力。</p><p>在职业生涯的早期就思考如何帮助您的同事成功，这会灌输正确的习惯，进而养成您自己的成功。</p><h4 id="Make-Hiring-Everyone’s-Responsibility"><a href="#Make-Hiring-Everyone’s-Responsibility" class="headerlink" title="Make Hiring Everyone’s Responsibility"></a>Make Hiring Everyone’s Responsibility</h4><p>让招聘成为每个人的责任</p><p>良好的面试过程可以实现两个目标。 首先，它筛选可能在团队中表现出色的人员类型。 其次，它使候选人对团队，任务和文化感到兴奋。</p><ul><li>花时间和你的团队一起考虑清楚，到底哪些特性对于潜在候选人是你最关心的</li><li>周期性的回顾讨论当前面试流程的有效性</li><li>设计面试问题，带有多个层次深度，以便能够适配不同能力水平的面试者</li><li>控制面试节奏以便获得更高的信噪比</li><li>通过迅速发出简短答案来探测广阔的表面来扫描危险信号</li><li>在面试中经常另一位团队成员配对</li><li>不要害怕使用非常规的面试方法，只要它们能帮助您确定团队所关心的信号</li></ul><h4 id="Design-a-Good-Onboarding-Process"><a href="#Design-a-Good-Onboarding-Process" class="headerlink" title="Design a Good Onboarding Process"></a>Design a Good Onboarding Process</h4><p>设计一个良好的入职流程</p><p>第一印象很重要。 良好的初始经验会影响工程师对工程文化的理解，影响其交付未来影响的能力，并根据团队的工作重点指导他的学习和活动。</p><p>入职流程的四个目标：</p><ul><li>新工程师尽快提升产出</li><li>传授团队文化和价值</li><li>使新工程师拥有成功所需的广泛基础知识</li><li>通过社交方式将新工程师整合到团队中</li></ul><h4 id="Share-Ownership-of-Code"><a href="#Share-Ownership-of-Code" class="headerlink" title="Share Ownership of Code"></a>Share Ownership of Code</h4><p>共享代码的主人翁意识</p><p>当你成为某个项目的瓶颈时，你就失去了做其他事情的灵活性。</p><p>策略：</p><ul><li>避免一个人的团队</li><li>互相 review 代码和设计</li><li>在整个团队中轮换任务</li><li>保持代码的可读性和质量</li><li>针对软件设计和架构进行技术演讲</li><li>文档化。不论是设计文档还是代码注释</li><li>记录完成工作所需的复杂工作流程或非显而易见的解决方法</li><li>花时间在教学和指导其他团队成员上</li></ul><h4 id="Build-Collective-Wisdom-through-Post-Mortems"><a href="#Build-Collective-Wisdom-through-Post-Mortems" class="headerlink" title="Build Collective Wisdom through Post-Mortems"></a>Build Collective Wisdom through Post-Mortems</h4><p>通过事后复盘来建立集体智慧</p><h4 id="Build-a-Great-Engineering-Culture"><a href="#Build-a-Great-Engineering-Culture" class="headerlink" title="Build a Great Engineering Culture"></a>Build a Great Engineering Culture</h4><p>建立伟大的工程师文化</p><p>伟大的工程师文化：</p><ol><li>为迭代速度而优化</li><li>持续无情的追求自动化</li><li>建立正确的软件抽象</li><li>通过代码评审关注高质量的代码</li><li>维护一个互相尊重的工作环境</li><li>建立一个共享的代码主人翁意识</li><li>在自动化测试上投入</li><li>分配实验性时间</li><li>培养持续学习和提升的文化</li><li>雇佣最优秀的人才</li></ol><h4 id="Key-Takeaways-7"><a href="#Key-Takeaways-7" class="headerlink" title="Key Takeaways"></a>Key Takeaways</h4><ul><li>帮助周围的同事成功</li><li>让招聘成为高优先级的事情</li><li>在入职流程和 mentor 机制上投入</li><li>建立代码的共享主人翁意识</li><li>沉淀集体智慧</li><li>建立伟大的工程师文化</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;高效的工程师是那些被认为可以把事情搞定的人。同时，是可以高效率的把事情搞定的人。&lt;/p&gt;
&lt;p&gt;高效工程师聚焦在价值和影响力上。&lt;/p&gt;
&lt;h2 id=&quot;Part-1-Adopt-the-Right-Mindsets&quot;&gt;&lt;a href=&quot;#Part-1-Adopt-the-Right-Mindsets&quot; class=&quot;headerlink&quot; title=&quot;Part 1: Adopt the Right Mindsets&quot;&gt;&lt;/a&gt;Part 1: Adopt the Right Mindsets&lt;/h2&gt;&lt;h3 id=&quot;Focus-on-High-Leverage-Activities&quot;&gt;&lt;a href=&quot;#Focus-on-High-Leverage-Activities&quot; class=&quot;headerlink&quot; title=&quot;Focus on High-Leverage Activities&quot;&gt;&lt;/a&gt;Focus on High-Leverage Activities&lt;/h3&gt;&lt;h4 id=&quot;Use-Leverage-as-Your-Yardstick-for-Effectiveness&quot;&gt;&lt;a href=&quot;#Use-Leverage-as-Your-Yardstick-for-Effectiveness&quot; class=&quot;headerlink&quot; title=&quot;Use Leverage as Your Yardstick for Effectiveness&quot;&gt;&lt;/a&gt;Use Leverage as Your Yardstick for Effectiveness&lt;/h4&gt;&lt;p&gt;杠杆率 = 产出 / 时间&lt;/p&gt;
&lt;p&gt;简单的说就是 ROI，投入产出比。&lt;/p&gt;
&lt;p&gt;时间是最宝贵的资源。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="读书摘要" scheme="https://0x01.io/tags/%E8%AF%BB%E4%B9%A6%E6%91%98%E8%A6%81/"/>
    
  </entry>
  
  <entry>
    <title>《程序员修炼之道：通往务实的最高境界》读书摘要</title>
    <link href="https://0x01.io/2020/05/15/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93%EF%BC%9A%E9%80%9A%E5%BE%80%E5%8A%A1%E5%AE%9E%E7%9A%84%E6%9C%80%E9%AB%98%E5%A2%83%E7%95%8C%E3%80%8B%E8%AF%BB%E4%B9%A6%E6%91%98%E8%A6%81/"/>
    <id>https://0x01.io/2020/05/15/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93%EF%BC%9A%E9%80%9A%E5%BE%80%E5%8A%A1%E5%AE%9E%E7%9A%84%E6%9C%80%E9%AB%98%E5%A2%83%E7%95%8C%E3%80%8B%E8%AF%BB%E4%B9%A6%E6%91%98%E8%A6%81/</id>
    <published>2020-05-15T15:26:05.000Z</published>
    <updated>2020-05-28T04:41:33.625Z</updated>
    
    <content type="html"><![CDATA[<h2 id="务实的哲学"><a href="#务实的哲学" class="headerlink" title="务实的哲学"></a>务实的哲学</h2><p>1、人生是你的</p><p>你有权选择<br>你可以去改变组织，或者让自己换一个组织<br>这个行业给了你一系列非凡的机遇。积极主动点，掌握这些机遇</p><p>2、我的源码被猫吃了</p><p>提供选择，别找借口</p><p>不要说搞不定</p><p>3、软件的熵</p><p>不要放任破窗（糟糕的设计、错误的决定、低劣的代码）</p><p>漠视会加速腐烂的过程</p><p>不要只是因为一些东西非常危急，就去造成附带损伤。破窗一扇都嫌太多。</p><a id="more"></a><p>4、石头做的汤和煮熟的青蛙</p><p>做推动变革的催化剂</p><p>永远留意大局，持续不断地审视你身边发生的事情，而不要只关注你个人在做的事情</p><p>5、够好即可的软件</p><p>将质量要求视为需求问题</p><p>与构想中的明天那个完美的软件相比，今天就还不错的软件通常更讨人喜欢</p><p>6、知识组合</p><p>知识和经验是你最重要的专业资产。可惜的是，它们是一种时效资产。</p><p>对知识组合做定期投资：</p><ol><li>每年学习一门新语言</li><li>每月读一本技术书</li><li>还要读非技术书</li><li>上课</li><li>加入本地的用户组和交流群</li><li>尝试不同的环境</li><li>与时俱进</li></ol><p>你是否在项目中使用过这些技术并不重要。学习的过程将会扩展你的思维。</p><p>时间总是不够用。所以你需要提前准备好，确保在无聊的时候有东西可读。</p><p>批判性地分析你读到和听到的东西。</p><p>7、交流</p><p>要了解听众，要有效的传递信息，不能空谈</p><p>总结：</p><ul><li>了解听众</li><li>明白自己想说什么</li><li>选择时机</li><li>挑选风格</li><li>让它看起来不错</li><li>让听众参与</li><li>做倾听者</li><li>回应别人</li></ul><p>越是有效的交流，影响力越大。</p><p>务实的程序员将文档视为整个开发过程的一个组成部分。</p><h2 id="务实的方法"><a href="#务实的方法" class="headerlink" title="务实的方法"></a>务实的方法</h2><p>8、优秀设计的精髓</p><p>优秀的设计比糟糕的设计更容易变更。能适应使用者的就是好设计。</p><p>ETC 原则：Easier To Change，更容易变更</p><p>ETC 是一种价值观念，不是一条规则。价值观念是帮助你做决定的。</p><p>9、DRY——邪恶的重复</p><p>DRY——不要重复自己</p><p>DRY 不限于编码。DRY 针对的是你对<em>知识</em>和<em>意图</em>的复制。</p><p>代码重复、文档中的重复、表征的重复、开发人员间的重复</p><p>10、正交性</p><p>正交性在计算机科学中象征着独立性或解耦性。对于两个或多个事物，其中一个的改变不影响其他任何一个，则这些事物是正交的。</p><p>正交的系统两个主要收益：提高生产力及降低风险</p><p>养成不断质疑代码的习惯。</p><p>11、可逆性</p><p>不设最终决定</p><p>让你的代码具备“摇滚”精神：顺境时摇摆滚动，逆境时直面困难</p><p>12、曳光弹</p><p>使用曳光弹找到目标</p><p>13、原型与便签</p><p>用原型学习。</p><p>你可以为下列事物做原型：</p><ul><li>架构</li><li>已存在的系统的新功能</li><li>数据结构或外部数据的内容</li><li>第三方工具或组件</li><li>性能问题</li><li>用户界面设计</li></ul><p>原型可以忽略以下细节：</p><ul><li>正确性</li><li>完整性</li><li>健壮性</li><li>格式</li></ul><p>14、领域语言</p><p>靠近问题域编程</p><p>通常，如果可以的话，就使用现成的外部语言（如YAML、JSON 或 CSV）。否则就试试内部语言。我们建议仅当应用程序的领域语言开放给用户来写的时候，才选择外部语言。</p><p>15、估算</p><p>通过估算来避免意外</p><p>挑选答案的单位来反映想要传达的精确性</p><p>所有的评估工作的首要部分都是建立对所问内容的理解。</p><p>根据代码不断迭代进度表</p><p>放慢节奏，花点时间完成本部分中描述的步骤，你总能得到更好的结果</p><h2 id="基础工具"><a href="#基础工具" class="headerlink" title="基础工具"></a>基础工具</h2><p>16、纯文本的威力</p><p>将知识用纯文本保存</p><p>优点：</p><ul><li>为防备老化而加保险</li><li>利用杠杆效应让已有的工具发挥最大优势</li><li>易于测试</li></ul><p>17、Shell 游戏</p><p>发挥 Shell 命令的威力</p><p>18、加强编辑能力</p><p>游刃有余的使用编辑器</p><p>19、版本控制</p><p>永远使用版本控制</p><p>20、调试</p><p>去解决问题，而不是责备</p><p>Bug 是你的错还是别人的错并不重要。无论谁的错，问题仍要你要面对。</p><p>调试的首要法则：不要恐慌</p><p>修代码前先让代码在测试中失败</p><p>不要假设，要证明</p><p>21、文本处理</p><p>学习一门文本处理语言</p><p>22、工程日记</p><p>试着拥有一本工程日记</p><h2 id="务实的偏执"><a href="#务实的偏执" class="headerlink" title="务实的偏执"></a>务实的偏执</h2><p>你无法写出完美的软件</p><p>注重实效的程序员连自己也不信任</p><p>23、契约式设计</p><p>通过契约进行设计</p><p>对接受的东西要求严格一点，并且尽可能的少对回报做出承诺</p><p>24、死掉的程序不会说谎</p><p>尽早崩溃</p><p>崩溃，不要制造垃圾</p><p>一个死掉的程序，通常比一个瘫痪的程序，造成的损害要小的多。</p><p>25、断言式编程</p><p>使用断言去预防不可能发生的事情</p><p>26、如何保持资源的平衡</p><p>处理资源分配和释放：要有始有终</p><p>分配资源的函数或对象，对释放资源应负有责任</p><p>27、不要冲出前灯范围</p><p>小步前进——由始至终</p><p>总是采取经过深思熟虑的小步骤，同时检查反馈，并在推进前不断调整。</p><p>与其浪费精力为不确定的未来做设计，还不如将代码设计成可替换的。</p><h2 id="宁弯不折"><a href="#宁弯不折" class="headerlink" title="宁弯不折"></a>宁弯不折</h2><p>28、解耦</p><p>解耦代码让改变更容易</p><p>任何时候，只要两段代码共享点什么东西，都可能发生耦合</p><p>只管命令不要询问</p><p>不应该根据对象的内部状态做出决策，然后更新该对象。这样做完全破话了封装的优势，也会把实现的相关知识扩散到整个代码中。</p><p>不要链式调用方法</p><p>避免全局数据</p><p><strong>继承增加了耦合</strong></p><p>再强调一次，一切都是为了变更</p><p>29、在现实世界中抛球杂耍</p><p>响应式应用程序：</p><ol><li>有限状态机</li><li>观察者模式</li><li>发布/订阅</li><li>响应式编程与流</li></ol><p>30、变换式编程</p><p>所有程序其实都是对数据的一种变换</p><p>不要囤积状态，传递下去</p><p>将代码看作一系列变换，可以为编程打开思路。</p><p>31、继承税</p><p>继承就是耦合</p><p>更好的替代方案：</p><ul><li>接口与协议</li><li>委托</li><li>mixin 与特征</li></ul><p>尽量用接口来表达多态</p><p>用委托提供服务：“有一个”胜过“是一个”</p><p>利用 mixin 共享功能</p><p>32、配置</p><p>使用外部配置参数化应用程序</p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>33、打破时域耦合</p><p>时域耦合指的是时间：并发性以及次序</p><p>通过分析工作流来提高并发性</p><p>34、共享状态是不正确的状态</p><p>随机故障通常是并发问题</p><p>35、角色与进程</p><p>用角色（actor）实现并发性时不必共享状态</p><p>36、黑板</p><p>使用黑板来协调工作流</p><p>消息系统可以像黑板一样工作</p><h2 id="当你编码时"><a href="#当你编码时" class="headerlink" title="当你编码时"></a>当你编码时</h2><p>37、听从蜥蜴脑</p><p>学会在编码时听从直觉是一项需要培养的重要技能</p><p>听从你的直觉，在问题跳出来之前加以避免</p><p>38、巧合式编程</p><p>我们应该避免通过巧合编程。编程应该深思熟虑。</p><p>39、算法速度</p><p>评估算法的级别</p><p>最好的不会永远最好</p><p>40、重构</p><p>软件更像园艺而非建筑</p><p>重构：</p><ul><li>重复：违背 DRY</li><li>非正交设计</li><li>过时的知识</li><li>使用</li><li>性能</li></ul><p>如果现在不进行重构，那么以后就需要投入更多的时间来解决问题</p><p>尽早重构，经常重构</p><p>技巧：</p><ul><li>不要试图让重构和添加功能同时进行</li><li>在开始重构之前确保有良好的测试</li><li>采取简短而慎重的步骤</li></ul><p>41、为编码测试</p><p>测试与找 BUG 无关</p><p>测试是代码的第一个用户</p><p>42、基于特性测试</p><p>使用基于特性的测试来校验假设</p><p>43、出门在外注意安全</p><p>基本原则：</p><ul><li>将攻击面的面积最小化</li><li>最小特权原则</li><li>安全的默认值</li><li>敏感数据要加密</li><li>维护安全更新</li></ul><p>当涉及加密时，第一条也是最重要的一条规则就是，永远不要自己做。</p><p>44、事物命名</p><p>在计算机科学中只有两件难事：缓存失效和命名</p><h2 id="在项目启动前"><a href="#在项目启动前" class="headerlink" title="在项目启动前"></a>在项目启动前</h2><p>45、需求之坑</p><p>无人确切知道自己想要什么</p><p>程序员帮助人们理解他们想要什么</p><p>需求是从反馈循环中学到的</p><p>和用户一起工作以便从用户的角度思考</p><p>使用项目术语表</p><p>46、处理无法解决的难题</p><p>不要跳出框框思考——找到框框</p><p>47、携手共建</p><p>不要一个人埋头冲进代码中</p><p>48、敏捷的本质</p><p>敏捷不是一个名词；敏捷有关你如何做事</p><p>敏捷宣言中的价值观：</p><p>我们一直在实践中探寻更好的软件开发方法，身体力行的同时也在帮助他人。由此我们建立了如下价值观：</p><ul><li><strong>个体和互动</strong>高于流程和工具</li><li><strong>工作的软件</strong>高于详尽的文档</li><li><strong>客户合作</strong>高于合同谈判</li><li><strong>响应变化</strong>高于遵循计划</li></ul><p>也就是说，尽管右项有其价值，我们更重视左项的价值。</p><h2 id="务实的项目"><a href="#务实的项目" class="headerlink" title="务实的项目"></a>务实的项目</h2><p>49、务实的团队</p><p>程序员有点像猫：聪明、意志坚强、固执己见、独立，并且经常引起网络崇拜。</p><p>维持小而稳定的团队</p><p>“只要有空闲时间”就去做，意味着这件事永远不会发生</p><p>50、椰子派不上用场</p><p>做能起作用的事，别赶时髦</p><p>51、务实的入门套件</p><p>务实的入门套件：</p><ul><li>版本控制</li><li>回归测试</li><li>完全自动化</li></ul><p>52、取悦用户</p><p>取悦用户，而不要只是交付代码</p><p>“解决问题的人”是一个务实的程序员的本质。</p><p>我们在解决问题</p><p>53、傲慢与偏见</p><p>在作品上签名</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;务实的哲学&quot;&gt;&lt;a href=&quot;#务实的哲学&quot; class=&quot;headerlink&quot; title=&quot;务实的哲学&quot;&gt;&lt;/a&gt;务实的哲学&lt;/h2&gt;&lt;p&gt;1、人生是你的&lt;/p&gt;
&lt;p&gt;你有权选择&lt;br&gt;你可以去改变组织，或者让自己换一个组织&lt;br&gt;这个行业给了你一系列非凡的机遇。积极主动点，掌握这些机遇&lt;/p&gt;
&lt;p&gt;2、我的源码被猫吃了&lt;/p&gt;
&lt;p&gt;提供选择，别找借口&lt;/p&gt;
&lt;p&gt;不要说搞不定&lt;/p&gt;
&lt;p&gt;3、软件的熵&lt;/p&gt;
&lt;p&gt;不要放任破窗（糟糕的设计、错误的决定、低劣的代码）&lt;/p&gt;
&lt;p&gt;漠视会加速腐烂的过程&lt;/p&gt;
&lt;p&gt;不要只是因为一些东西非常危急，就去造成附带损伤。破窗一扇都嫌太多。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="读书笔记" scheme="https://0x01.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《程序员修炼之道：从小工到专家》读书摘要</title>
    <link href="https://0x01.io/2020/05/07/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93%EF%BC%9A%E4%BB%8E%E5%B0%8F%E5%B7%A5%E5%88%B0%E4%B8%93%E5%AE%B6%E3%80%8B%E8%AF%BB%E4%B9%A6%E6%91%98%E8%A6%81/"/>
    <id>https://0x01.io/2020/05/07/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93%EF%BC%9A%E4%BB%8E%E5%B0%8F%E5%B7%A5%E5%88%B0%E4%B8%93%E5%AE%B6%E3%80%8B%E8%AF%BB%E4%B9%A6%E6%91%98%E8%A6%81/</id>
    <published>2020-05-07T12:10:42.000Z</published>
    <updated>2020-05-28T04:41:33.625Z</updated>
    
    <content type="html"><![CDATA[<h2 id="注重实效的哲学"><a href="#注重实效的哲学" class="headerlink" title="注重实效的哲学"></a>注重实效的哲学</h2><p>1、我的源码让猫吃了<br>要为自己的项目负责，不要找借口，而是要找选择，找解决方案</p><p>2、软件的熵<br>破窗理论<br>不要容忍“破窗户”（低劣的设计、错误决策、糟糕代码）<br>一个干净整洁没有破窗的项目，其他人也不忍心第一个破坏它。但是一旦有破窗，其他人也就不在乎了，破窗越来越多。</p><p>3、石头汤与煮青蛙<br>做变化的催化剂<br>遇到问题的时候，尽管会面临其他人或者团队的无法支持。但是主动的去做，去拿出一个你可以拿出的可用的原型。这个时候，相关的人和团队就会发现，自己向上面添加东西，就会变得更好。<br>记住大图景。避免温水煮青蛙。</p><a id="more"></a><p>4、足够好的软件<br>今天的了不起的软件常常比明天的完美软件更可取。<br>不要过度求精，软件不可能完美。</p><p>5、你的知识资产<br>定期为你的知识资产投资<br>持续学习</p><ul><li>每年至少学习一种新语言</li></ul><ul><li>每季度阅读一本技术书籍</li><li>也要阅读非技术书籍</li><li>上课</li><li>参与本地用户组织</li><li>试验不同的环境</li><li>跟上潮流</li><li>上网<br>批判的分析你读到和听到的</li></ul><p>6、交流<br>要了解听众，要有效的传递信息，不能空谈<br>应该总是对电子邮件或者语音作出回应。<br>总结：</p><ul><li>知道你要说什么</li></ul><ul><li>了解你的听众</li><li>选择时机</li><li>选择风格</li><li>让文档美观</li><li>让听众参与</li><li>做倾听者</li><li>回复他人</li></ul><h2 id="注重实效的途径"><a href="#注重实效的途径" class="headerlink" title="注重实效的途径"></a>注重实效的途径</h2><p>7、重复的危害<br>DRY：系统中的每一项知识都必须具有单一、无歧义、权威的表示</p><p>8、正交性<br>消除无关事物之间的影响<br>正交系统：提高生产率、降低风险<br>团队组织也要有正交性<br>养成不断地批判对待自己的代码的习惯</p><p>9、可撤销性<br>不存在最终决策，让代码学会“摇滚”</p><p>10、曳光弹<br>原型制作生成用过就扔的代码。曳光弹代码虽然简约，但却是完整的，并且构成最终系统骨架的一部分。<br>可以把原型制作视为在第一发曳光弹发射之前进行的侦查和情报搜集工作。</p><p>11、原型与便笺<br>为了学习而制作原型</p><p>12、领域语言<br>靠近问题领域编程</p><p>13、估算<br>估算，以避免发生意外<br>估算的第一步都是建立在对提问内容的理解<br>放慢估算的速度，仔细检查在这一节描述的步骤，几乎总能得到更好的结果</p><h2 id="基本工具"><a href="#基本工具" class="headerlink" title="基本工具"></a>基本工具</h2><p>14、纯文本的威力<br>持久存储知识的最佳格式是纯文本<br>用纯文本保存知识</p><p>威力：</p><ol><li>保证不过时</li><li>杠杆作用：围绕一堆基于纯文本的工具链</li><li>更易于测试</li></ol><p>15、shell 游戏<br>利用命令 shell 的力量</p><p>16、强力编辑<br>用好一种编辑器，并将其用于所有编辑任务</p><p>17、源码控制<br>总是使用源码控制</p><p>18、调试<br>要修正问题，而不是发出指责<br>不要恐慌<br>开始修正 bug 的最佳途径是再现 bug<br>不要假定、要证明</p><p>19、文本操纵<br>学习一种文本操纵语言</p><p>20、代码生成器<br>编写能编写代码的代码</p><h2 id="注重实效的偏执"><a href="#注重实效的偏执" class="headerlink" title="注重实效的偏执"></a>注重实效的偏执</h2><p>你不可能写出完美的软件<br>注重实效的程序员连自己也不信任</p><p>21、按合约设计<br>什么是正确的程序？不多不少，做它声明要做的事情的程序。<br>对接受的东西要严格，而允诺返回的东西要尽可能少<br>可以通过断言进行部分模拟</p><p>22、死程序不说谎<br>早崩溃<br>让你的程序崩溃是最佳选择<br>死程序带来的危害通常比有疾患的程序小的多</p><p>23、断言式编程<br>如果它不可能发生，用断言确保它不会发生<br>不要用断言代替真正的错误处理，断言检查的是决不应该发生的事情</p><p>24、何时使用异常<br>将异常用于异常的问题</p><p>25、怎样配平资源<br>要有始有终<br>分配某项资源的对象应该负责解除该资源的分配</p><h2 id="弯曲，或折断"><a href="#弯曲，或折断" class="headerlink" title="弯曲，或折断"></a>弯曲，或折断</h2><p>创建灵活代码的一个关键概念是数据模型（model）与该模型的视图（view）的分离</p><p>26、解耦与得墨忒耳法则<br>把你的代码组织成最小组织单位（模块），并限制它们之间的交互<br>使模块之间的耦合减至最少<br>通过反转得墨忒耳法则，是若干模块<strong>紧密</strong>耦合，你可以获得重大的性能改进</p><p>27、元程序设计<br>要配置，不要集成<br>将抽象放进代码，细节放进元数据</p><p>28、时间耦合<br>我们要容许并发<br>分析工作流，以改善并发性<br>总是为并发进行设计</p><p>29、它只是视图<br>模块的一个好定义就是，它具有单一的、定义良好的责任<br>使视图与模型分离</p><p>30、黑板<br>用黑板协调工作流</p><h2 id="当你编码时"><a href="#当你编码时" class="headerlink" title="当你编码时"></a>当你编码时</h2><p>31、靠巧合编程<br>不要靠巧合编程</p><ul><li>总是意识到你在做什么</li><li>不要盲目的编程</li><li>按照计划行事</li><li>依靠可靠的事物</li><li>为你的假定建立文档</li><li>不要只是测试你的代码，还要测试你的假定</li><li>为你的工作划分优先级</li><li>不要做历史的奴隶</li></ul><p>32、算法速率<br>估算你算法的阶<br>测试你的估算</p><p>33、重构<br>不要对改动犹豫不决，应该现在就做<br>无论代码具有下面的哪些特性，你都应该考虑重构代码：</p><ul><li>重复</li><li>非正交设计</li><li>过时的知识</li><li>性能</li><li>早重构，常重构*<br>提示：</li></ul><ol><li>不要试图在重构的同时增加功能</li><li>在开始重构之前，确保拥有良好的测试</li><li>采取短小、深思熟虑的步骤</li></ol><p>34、易于测试的代码<br>为测试而设计<br>通过使测试代码易于找到，你是在给你的代码开发者提供两样无价的资源：</p><ol><li>一些例子，说明怎样使用你的模块的所有功能</li><li>用以构建回归测试、以验证未来对代码的任何改动是否正确的一种手段</li></ol><p>35、邪恶的向导<br>不要使用你不理解的向导代码</p><h2 id="项目开始之前"><a href="#项目开始之前" class="headerlink" title="项目开始之前"></a>项目开始之前</h2><p>36、需求之坑<br>不要搜集需求——挖掘它们<br>找出用户为何要做特定事情的原因、而不只是他们目前做这件事情的方式<br>你的开发必须解决他们的商业问题，而不只是满足他们陈述的需求<br>与用户一同工作，以像用户一样思考<br>使用项目词汇表</p><p>37、解开不可能解开的谜题<br>对需求的重新诠释能让整个问题全部消失<br>你所需要的只是真正的约束、令人误解的约束、还有区分它们的智慧</p><p>38、等你准备好<br>倾听反复出现的疑虑——等你准备好再开始<br>从“政治策略”角度说，去构建原型也许比简单地宣布“我觉得不该启动”、并开始玩单人纸牌游戏更能让人接受</p><p>39、规范陷阱<br>对有些事情“做”胜于“描述”</p><p>40、圆圈与箭头<br>不要做形式方法的奴隶<br>注重实效的程序员批判的看待方法学，并从各种方法学中提取精华，融合成每个月都在变得更好的一套工作习惯<br>你应该不断努力提炼和改善你的开发过程</p><h2 id="注重实效的项目"><a href="#注重实效的项目" class="headerlink" title="注重实效的项目"></a>注重实效的项目</h2><p>使项目级活动保持一致和可靠的一个最重要的因素是使你的各种工作流程自动化</p><p>41、注重实效的团队<br>不要留破窗户<br>围绕功能、而不是工作职务进行组织<br>我们是在寻求内聚的、在很大程度上自足的团队<br>让每个成员都能以他们自己的方式闪亮</p><p>42、无处不在的自动化<br>不要使用手工流程</p><p>43、无情的测试<br>早测试，常测试，自动测试<br>要到通过全部测试，编码才算完成<br>一个 bug 只抓一次：如果有 bug 漏过了现有的测试网，你需要增加新的测试，以在下一次抓住它</p><p>44、全都是写<br>好记性不如烂笔头<br>一般而言，注释应该讨论为何要做某事、它的目的和目标</p><p>45、极大的期望<br>温和的超出用户的期望</p><p>46、傲慢与偏见<br>在你的作品上签名<br>注重实效的程序员不会逃避责任，相反，我们乐于接受挑战。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;注重实效的哲学&quot;&gt;&lt;a href=&quot;#注重实效的哲学&quot; class=&quot;headerlink&quot; title=&quot;注重实效的哲学&quot;&gt;&lt;/a&gt;注重实效的哲学&lt;/h2&gt;&lt;p&gt;1、我的源码让猫吃了&lt;br&gt;要为自己的项目负责，不要找借口，而是要找选择，找解决方案&lt;/p&gt;
&lt;p&gt;2、软件的熵&lt;br&gt;破窗理论&lt;br&gt;不要容忍“破窗户”（低劣的设计、错误决策、糟糕代码）&lt;br&gt;一个干净整洁没有破窗的项目，其他人也不忍心第一个破坏它。但是一旦有破窗，其他人也就不在乎了，破窗越来越多。&lt;/p&gt;
&lt;p&gt;3、石头汤与煮青蛙&lt;br&gt;做变化的催化剂&lt;br&gt;遇到问题的时候，尽管会面临其他人或者团队的无法支持。但是主动的去做，去拿出一个你可以拿出的可用的原型。这个时候，相关的人和团队就会发现，自己向上面添加东西，就会变得更好。&lt;br&gt;记住大图景。避免温水煮青蛙。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="读书笔记" scheme="https://0x01.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>x86 软路由透明代理构建方案v2020.02</title>
    <link href="https://0x01.io/2020/02/16/x86-%E8%BD%AF%E8%B7%AF%E7%94%B1%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86%E6%9E%84%E5%BB%BA%E6%96%B9%E6%A1%88v2020-02/"/>
    <id>https://0x01.io/2020/02/16/x86-%E8%BD%AF%E8%B7%AF%E7%94%B1%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86%E6%9E%84%E5%BB%BA%E6%96%B9%E6%A1%88v2020-02/</id>
    <published>2020-02-16T18:29:39.000Z</published>
    <updated>2020-05-28T04:41:33.625Z</updated>
    
    <content type="html"><![CDATA[<p>2017 年的时候写过关于 <a href="/2017/04/01/x86-%E8%BD%AF%E8%B7%AF%E7%94%B1%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86%E6%9E%84%E5%BB%BA%E6%96%B9%E6%A1%88/" title="x86 软路由透明代理构建方案">x86 软路由透明代理构建方案</a>，当时的方案是基于 overture + redsocks + shadowsocks 做的。当时用的还挺好的。</p><p>但是随着时间的推移，整个社区在变化，方案也在变化。主要遇到的几个想要迁移修改的想法，一个是 redsocks 比较老，bug 多，不怎么稳定，而且不维护了。虽然有人自己改了 redsocks2 的方案，但也不那么完美吧。二个是 shadowsocks 的问题，这个众所周知了，就不描述背景了。三个是 clash 的崛起，确实挺好用，主要是一体化解决问题，还有节点维护管理能力。所以起了换 clash 的想法。</p><p>所以，目前新的方案是 overture + clash。其实 clash 自带 dns server，但是我觉得不够稳，也不够好用，还是继续用了 overture。部署新方案的过程中，也踩了几个坑，下面主要是想记录一下这几个坑。</p><a id="more"></a><h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><p>网络配置：<br>    双网卡 + NAT（iptable）+ DHCP<br>DNS 解析防污染：<br>    <a href="https://github.com/shawn1m/overture" target="_blank" rel="noopener">overture</a>（解析）+ dnsmasq（缓存）<br>代理：<br>    clash<br>透明代理：<br>    iptable + ipset（国内 IP 段）</p><h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><p>这部分不再赘述，可以继续参考 <a href="/2017/04/01/x86-%E8%BD%AF%E8%B7%AF%E7%94%B1%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86%E6%9E%84%E5%BB%BA%E6%96%B9%E6%A1%88/" title="x86 软路由透明代理构建方案">x86 软路由透明代理构建方案</a> 中的 网络配置 部分。</p><h2 id="DNS-解析防污染"><a href="#DNS-解析防污染" class="headerlink" title="DNS 解析防污染"></a>DNS 解析防污染</h2><p>这部分和 <a href="/2017/04/01/x86-%E8%BD%AF%E8%B7%AF%E7%94%B1%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86%E6%9E%84%E5%BB%BA%E6%96%B9%E6%A1%88/" title="x86 软路由透明代理构建方案">x86 软路由透明代理构建方案</a> 中的 DNS 解析防污染 部分一样，只是升级了一下 overture 的配置文件。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"BindAddress"</span>: <span class="string">":54"</span>,</span><br><span class="line">  <span class="attr">"DebugHTTPAddress"</span>: <span class="string">"127.0.0.1:5555"</span>,</span><br><span class="line">  <span class="attr">"PrimaryDNS"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"Name"</span>: <span class="string">"DNSPod"</span>,</span><br><span class="line">      <span class="attr">"Address"</span>: <span class="string">"119.29.29.29:53"</span>,</span><br><span class="line">      <span class="attr">"Protocol"</span>: <span class="string">"udp"</span>,</span><br><span class="line">      <span class="attr">"SOCKS5Address"</span>: <span class="string">""</span>,</span><br><span class="line">      <span class="attr">"Timeout"</span>: <span class="number">6</span>,</span><br><span class="line">      <span class="attr">"EDNSClientSubnet"</span>: &#123;</span><br><span class="line">        <span class="attr">"Policy"</span>: <span class="string">"disable"</span>,</span><br><span class="line">        <span class="attr">"ExternalIP"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"NoCookie"</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"AlternativeDNS"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"Name"</span>: <span class="string">"cloudflare"</span>,</span><br><span class="line">      <span class="attr">"Address"</span>: <span class="string">"1.1.1.1:53"</span>,</span><br><span class="line">      <span class="attr">"Protocol"</span>: <span class="string">"tcp"</span>,</span><br><span class="line">      <span class="attr">"SOCKS5Address"</span>: <span class="string">"127.0.0.1:10080"</span>,</span><br><span class="line">      <span class="attr">"Timeout"</span>: <span class="number">6</span>,</span><br><span class="line">      <span class="attr">"EDNSClientSubnet"</span>: &#123;</span><br><span class="line">        <span class="attr">"Policy"</span>: <span class="string">"disable"</span>,</span><br><span class="line">        <span class="attr">"ExternalIP"</span>: <span class="string">""</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"Name"</span>: <span class="string">"Google"</span>,</span><br><span class="line">      <span class="attr">"Address"</span>: <span class="string">"8.8.8.8:53"</span>,</span><br><span class="line">      <span class="attr">"Protocol"</span>: <span class="string">"tcp"</span>,</span><br><span class="line">      <span class="attr">"SOCKS5Address"</span>: <span class="string">"127.0.0.1:10080"</span>,</span><br><span class="line">      <span class="attr">"Timeout"</span>: <span class="number">6</span>,</span><br><span class="line">      <span class="attr">"EDNSClientSubnet"</span>: &#123;</span><br><span class="line">        <span class="attr">"Policy"</span>: <span class="string">"disable"</span>,</span><br><span class="line">        <span class="attr">"ExternalIP"</span>: <span class="string">""</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"OnlyPrimaryDNS"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"IPv6UseAlternativeDNS"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"RedirectIPv6Record"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"WhenPrimaryDNSAnswerNoneUse"</span>: <span class="string">"PrimaryDNS"</span>,</span><br><span class="line">  <span class="attr">"IPNetworkFile"</span>: &#123;</span><br><span class="line">    <span class="attr">"Primary"</span>: <span class="string">"/etc/overture/ip_network_sample"</span>,</span><br><span class="line">    <span class="attr">"Alternative"</span>: <span class="string">"/etc/overture/ip_network_alternative_sample"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"DomainFile"</span>: &#123;</span><br><span class="line">    <span class="attr">"Primary"</span>: <span class="string">"/etc/overture/domain_sample"</span>,</span><br><span class="line">    <span class="attr">"Alternative"</span>: <span class="string">"/etc/overture/domain_alternative_sample"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"HostsFile"</span>: <span class="string">"/etc/overture/hosts_sample"</span>,</span><br><span class="line">  <span class="attr">"MinimumTTL"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"DomainTTLFile"</span> : <span class="string">"/etc/overture/domain_ttl_sample"</span>,</span><br><span class="line">  <span class="attr">"CacheSize"</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"RejectQType"</span>: [<span class="number">255</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是 DNS 上游解析走 tcp，并且使用 <code>SOCKS5Address</code> 将 DNS 解析走代理。当然也可以用 tcp-tls 类型，就是 DNS over TLS，和 tcp 走代理差别不大。</p><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><h3 id="clash"><a href="#clash" class="headerlink" title="clash"></a>clash</h3><p>安装 clash，就是从 github 上下载已经编译好的二进制包。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /opt/clash &amp;&amp; cd /opt/clash</span><br><span class="line">wget https://github.com/Dreamacro/clash/releases/download/v0.17.1/clash-linux-amd64-v0.17.1.gz</span><br><span class="line">gzip -d clash-linux-amd64-v0.17.1.gz</span><br><span class="line">mv clash-linux-amd64-v0.14.0 clash</span><br><span class="line">chmod +x clash</span><br></pre></td></tr></table></figure><p>一个大坑是，clash 的 direct 规则出来的请求，到下面的 iptable 规则的时候，会被重新 redirect 回来给 clash，形成回环。这种时候，socket fd 会爆掉。</p><p>所以解决方案是，给 clash 单独建一个新的 user，在 iptable 加个针对 user 的规则。主要是参考了<a href="https://github.com/Dreamacro/clash/issues/158#issuecomment-480444965" target="_blank" rel="noopener">这里</a>的方案。通过 <code>adduser clash</code> 新建一个叫 clash 的用户，创建了其主目录 <code>/home/clash/</code>。</p><p>通过 <code>id clash</code> 得知其 uid 是 <code>1001</code>。下面 iptable 规则需要用。</p><p>下面的配置文件可以放在 <code>/home/clash/.config/clash/</code> 目录下。</p><p>配置文件，前若干行</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">port:</span> <span class="number">8888</span></span><br><span class="line"><span class="attr">socks-port:</span> <span class="number">10080</span></span><br><span class="line"><span class="attr">redir-port:</span> <span class="number">12345</span></span><br><span class="line"><span class="attr">allow-lan:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">mode:</span> <span class="string">Rule</span></span><br><span class="line"><span class="attr">log-level:</span> <span class="string">warning</span></span><br><span class="line"><span class="attr">external-controller:</span> <span class="string">'0.0.0.0:6170'</span></span><br><span class="line"><span class="attr">secret:</span> <span class="string">''</span></span><br><span class="line"><span class="attr">cfw-latency-url:</span> <span class="string">'http://www.gstatic.com/generate_204'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有用 dns</span></span><br><span class="line"><span class="attr">dns:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">ipv6:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">listen:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">:54</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">nameserver:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="number">1.2</span><span class="number">.4</span><span class="number">.8</span></span><br><span class="line">     <span class="bullet">-</span> <span class="number">114.114</span><span class="number">.114</span><span class="number">.114</span></span><br><span class="line">     <span class="bullet">-</span> <span class="number">223.5</span><span class="number">.5</span><span class="number">.5</span></span><br><span class="line">     <span class="comment">#- tls://dns.rubyfish.cn:853</span></span><br><span class="line">     <span class="comment">#- https://dns.rubyfish.cn/dns-query</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">fallback:</span> <span class="comment"># 与 nameserver 内的服务器列表同时发起请求，当规则符合 GEOIP 在 CN 以外时，fallback 列表内的域名服务器生效。</span></span><br><span class="line">     <span class="comment">#- tls://dns.rubyfish.cn:853</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">tls://1.0.0.1:853</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">tls://dns.google:853</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">#- https://dns.rubyfish.cn/dns-query</span></span><br><span class="line">     <span class="comment">#- https://cloudflare-dns.com/dns-query</span></span><br><span class="line">     <span class="comment">#- https://dns.google/dns-query</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">Proxy:</span></span><br><span class="line"><span class="string">以下省略</span></span><br></pre></td></tr></table></figure><p>主要是说明一下我用的几个端口号，方便后面使用。</p><p>其中的坑一，<code>allow-lan: true</code> 必须为 true。</p><p>clash 的启动，我还是习惯用 suprvisor，习惯了。用 github 上 clash 自己用的 pm2 也行。或者自己配置 systemd 都行。只要确定启动 clash 进程的时候，必须使用 <code>clash</code> 这个用户。在 supervisor 里的配置是加一个 <code>user=clash</code> 的配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[program:clash]</span><br><span class="line">user&#x3D;clash</span><br><span class="line">priority&#x3D;1</span><br><span class="line">command&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;clash -d &#x2F;home&#x2F;clash&#x2F;.config&#x2F;clash&#x2F;</span><br><span class="line">autorestart&#x3D;true</span><br></pre></td></tr></table></figure><p>上面路径自行替换。</p><h2 id="透明代理"><a href="#透明代理" class="headerlink" title="透明代理"></a>透明代理</h2><p>这部分和 <a href="/2017/04/01/x86-%E8%BD%AF%E8%B7%AF%E7%94%B1%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86%E6%9E%84%E5%BB%BA%E6%96%B9%E6%A1%88/" title="x86 软路由透明代理构建方案">x86 软路由透明代理构建方案</a> 中的 透明代理 部分基本一样。只是加了几条规则。</p><p>最终的 iptable 表如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Chain PREROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">SHADOWSOCKS  tcp  --  anywhere             anywhere</span><br><span class="line"></span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">RETURN     all  --  anywhere             anywhere             owner UID match clash</span><br><span class="line">SHADOWSOCKS  tcp  --  anywhere             anywhere</span><br><span class="line"></span><br><span class="line">Chain POSTROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">MASQUERADE  all  --  anywhere             anywhere</span><br><span class="line"></span><br><span class="line">Chain SHADOWSOCKS (2 references)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">RETURN     tcp  --  anywhere             anywhere             tcp dpt:10144</span><br><span class="line">RETURN     udp  --  anywhere             anywhere             udp dpts:4096:65535</span><br><span class="line">RETURN     all  --  anywhere             0.0.0.0&#x2F;8</span><br><span class="line">RETURN     all  --  anywhere             10.0.0.0&#x2F;8</span><br><span class="line">RETURN     all  --  anywhere             127.0.0.0&#x2F;8</span><br><span class="line">RETURN     all  --  anywhere             link-local&#x2F;16</span><br><span class="line">RETURN     all  --  anywhere             172.16.0.0&#x2F;12</span><br><span class="line">RETURN     all  --  anywhere             192.168.0.0&#x2F;16</span><br><span class="line">RETURN     all  --  anywhere             base-address.mcast.net&#x2F;4</span><br><span class="line">RETURN     all  --  anywhere             240.0.0.0&#x2F;4</span><br><span class="line">RETURN     tcp  --  anywhere             anywhere             match-set chnroute dst</span><br><span class="line">REDIRECT   tcp  --  anywhere             anywhere             redir ports 12345</span><br></pre></td></tr></table></figure><p>加了两条规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A OUTPUT -m owner --uid-owner 1001 -j RETURN</span><br><span class="line">iptables -t nat -A OUTPUT -p tcp -j SHADOWSOCKS</span><br></pre></td></tr></table></figure><p>第一条是避免形成回环，第二条是让网关本身可以翻墙。</p><p>然后还是用 iptables-persistent 持久化，基本就可以用了。</p><h2 id="内核参数"><a href="#内核参数" class="headerlink" title="内核参数"></a>内核参数</h2><p>这里我又被坑了一把。之前不知道啥时候，内核参数里加了一个 <code>net.ipv4.tcp_tw_recycle = 1</code>，然后就坑了。</p><p>导致的问题是，设备发送的 tcp 的 syn 包，被网关默默的 drop 掉了。通过 tcpdump 发现，发送出去的 tcp syn，但是没有收到任何回复。局域网内会间歇性的无法翻墙，http connect 经常超时，请求并没有走到 clash，clash 没有相应的日志。最终在 <a href="https://zhuanlan.zhihu.com/p/99653071" target="_blank" rel="noopener">这里</a> 的第三部分，关于 <code>net.ipv4.tcp_tw_recycle</code> 部分，把 1 改回 0 就好了。</p><p>网上看了一下，这个内核参数，不要乱改，基本没啥用，改了有问题，到 linux 4.14 还是什么版本来着，这个参数直接被干掉了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017 年的时候写过关于 &lt;a href=&quot;/2017/04/01/x86-%E8%BD%AF%E8%B7%AF%E7%94%B1%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86%E6%9E%84%E5%BB%BA%E6%96%B9%E6%A1%88/&quot; title=&quot;x86 软路由透明代理构建方案&quot;&gt;x86 软路由透明代理构建方案&lt;/a&gt;，当时的方案是基于 overture + redsocks + shadowsocks 做的。当时用的还挺好的。&lt;/p&gt;
&lt;p&gt;但是随着时间的推移，整个社区在变化，方案也在变化。主要遇到的几个想要迁移修改的想法，一个是 redsocks 比较老，bug 多，不怎么稳定，而且不维护了。虽然有人自己改了 redsocks2 的方案，但也不那么完美吧。二个是 shadowsocks 的问题，这个众所周知了，就不描述背景了。三个是 clash 的崛起，确实挺好用，主要是一体化解决问题，还有节点维护管理能力。所以起了换 clash 的想法。&lt;/p&gt;
&lt;p&gt;所以，目前新的方案是 overture + clash。其实 clash 自带 dns server，但是我觉得不够稳，也不够好用，还是继续用了 overture。部署新方案的过程中，也踩了几个坑，下面主要是想记录一下这几个坑。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="翻墙" scheme="https://0x01.io/tags/%E7%BF%BB%E5%A2%99/"/>
    
      <category term="shadowsocks" scheme="https://0x01.io/tags/shadowsocks/"/>
    
      <category term="软路由" scheme="https://0x01.io/tags/%E8%BD%AF%E8%B7%AF%E7%94%B1/"/>
    
      <category term="clash" scheme="https://0x01.io/tags/clash/"/>
    
  </entry>
  
  <entry>
    <title>Pillow踩坑记录之图片水印</title>
    <link href="https://0x01.io/2018/03/29/Pillow%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%E4%B9%8B%E5%9B%BE%E7%89%87%E6%B0%B4%E5%8D%B0/"/>
    <id>https://0x01.io/2018/03/29/Pillow%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%E4%B9%8B%E5%9B%BE%E7%89%87%E6%B0%B4%E5%8D%B0/</id>
    <published>2018-03-29T14:35:44.000Z</published>
    <updated>2020-05-28T04:41:33.625Z</updated>
    
    <content type="html"><![CDATA[<p>好久没写博客了。最近在做图片水印功能，本来觉得难度不大，照着 Pillow 文档随便搞搞就行了。没想到设计师验收的时候发现一堆坑。也许是学艺不精，没有仔细研究过 Pillow，只是随便看看文档做的，可能是我用的姿势不对才导致一堆坑。</p><p>基本需求是：</p><ol><li>前面一个品牌 logo</li><li>后面一个 @用户名，用思源黑体常规字重的字体</li><li>有投影效果</li><li>整体大小和图片宽度成比例</li></ol><p>首先去 Pillow 文档里找了个 <a href="http://pillow.readthedocs.io/en/latest/reference/ImageDraw.html#example-draw-partial-opacity-text" target="_blank" rel="noopener">example</a></p><p>在网上查一些 blog 也都是这么写的，于是就照着写了一个基本的。</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># encoding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw, ImageFont</span><br><span class="line"></span><br><span class="line">SourceHanSans_font = <span class="string">'~/SourceHanSansCN-Regular.otf'</span></span><br><span class="line"></span><br><span class="line">STANDARD_SIDE_MARGIN = <span class="number">12</span>  <span class="comment"># 右边距</span></span><br><span class="line">STANDARD_BOTTOM_MARGIN = <span class="number">10</span>  <span class="comment"># 下边距</span></span><br><span class="line">SHADOW_OFFSET = <span class="number">1</span>  <span class="comment"># 水印阴影偏移</span></span><br><span class="line"></span><br><span class="line">im = Image.open(<span class="string">'test.jpg'</span>).convert(<span class="string">"RGBA"</span>)</span><br><span class="line">username = <span class="string">u'＠用户名'</span></span><br><span class="line"></span><br><span class="line">im_width, im_height = im.size</span><br><span class="line"></span><br><span class="line"><span class="comment"># 450 宽度是基准，设计要求小于这个宽度的不会有水印</span></span><br><span class="line">scale = im_width * <span class="number">1.0</span> / <span class="number">450</span></span><br><span class="line"></span><br><span class="line">font = ImageFont.truetype(SourceHanSans_font, size=int(round(<span class="number">13</span> * scale)))  <span class="comment"># 13 号字体也是基准</span></span><br><span class="line">text = username</span><br><span class="line">text_width, text_height = font.getsize(text)</span><br><span class="line">text_x = int(round(im_width - STANDARD_SIDE_MARGIN * scale - text_width))</span><br><span class="line">text_y = int(round(im_height - STANDARD_BOTTOM_MARGIN * scale - text_height))</span><br><span class="line"></span><br><span class="line">txt = Image.new(<span class="string">'RGBA'</span>, im.size, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">draw = ImageDraw.Draw(txt)</span><br><span class="line"></span><br><span class="line">draw.text((text_x + int(round(SHADOW_OFFSET * scale)), text_y + int(round(SHADOW_OFFSET * scale))), text, font=font, fill=(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">77</span>))  <span class="comment"># 黑色 40% 不透明度的阴影</span></span><br><span class="line">draw.text((text_x, text_y), text, font=font, fill=(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>))  <span class="comment"># 白色</span></span><br><span class="line">r = Image.alpha_composite(combined, txt)</span><br><span class="line">draw = ImageDraw.Draw(r)</span><br><span class="line"></span><br><span class="line">r.save(<span class="string">"result.jpg"</span>, format=<span class="string">"JPEG"</span>, quality=<span class="number">95</span>)  <span class="comment"># 不设置quality的话会默认以 75 的质量保存，损失很多画质，95 是最大值。</span></span><br></pre></td></tr></table></figure><p>看起来还可以啊，计算好文字的长宽，先绘制投影。投影就是一个黑色带透明度的同样的文字，(x,y) 坐标分别向右和下增加若干像素。绘制完之后，再在原来的 (x,y) 位置绘制白色文字就行了。文字都绘制到一张空白的透明图上，然后把两个图层贴一块就行了。</p><p>搞出来发现，怎么文字不是按照我说的 (x,y) 放置，y 坐标偏移了若干像素呢？</p><p>然后网上查了一圈发现，字体这个东西，原来是有个 offset 的概念的。绘制的时候把 offset 自己减去就行了。晕。改一把。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># encoding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw, ImageFont</span><br><span class="line"></span><br><span class="line">SourceHanSans_font = <span class="string">'~/SourceHanSansCN-Regular.otf'</span></span><br><span class="line"></span><br><span class="line">STANDARD_SIDE_MARGIN = <span class="number">12</span>  <span class="comment"># 右边距</span></span><br><span class="line">STANDARD_BOTTOM_MARGIN = <span class="number">10</span>  <span class="comment"># 下边距</span></span><br><span class="line">SHADOW_OFFSET = <span class="number">1</span>  <span class="comment"># 水印阴影偏移</span></span><br><span class="line"></span><br><span class="line">im = Image.open(<span class="string">'test.jpg'</span>).convert(<span class="string">"RGBA"</span>)</span><br><span class="line">username = <span class="string">u'＠用户名'</span></span><br><span class="line"></span><br><span class="line">im_width, im_height = im.size</span><br><span class="line"></span><br><span class="line"><span class="comment"># 450 宽度是基准，设计要求小于这个宽度的不会有水印</span></span><br><span class="line">scale = im_width * <span class="number">1.0</span> / <span class="number">450</span></span><br><span class="line"></span><br><span class="line">font = ImageFont.truetype(SourceHanSans_font, size=int(round(<span class="number">13</span> * scale)))  <span class="comment"># 13 号字体也是基准</span></span><br><span class="line">text = username</span><br><span class="line">text_width, text_height = font.getsize(text)</span><br><span class="line">text_x_offset, text_y_offset = font.getoffset(text)  <span class="comment"># 这里</span></span><br><span class="line">text_x = int(round(im_width - STANDARD_SIDE_MARGIN * scale - text_width))</span><br><span class="line">text_y = int(round(im_height - STANDARD_BOTTOM_MARGIN * scale - text_height))</span><br><span class="line"></span><br><span class="line">txt = Image.new(<span class="string">'RGBA'</span>, im.size, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">draw = ImageDraw.Draw(txt)</span><br><span class="line"></span><br><span class="line">draw.text((text_x - text_x_offset + int(round(SHADOW_OFFSET * scale)), text_y - text_y_offset + int(round(SHADOW_OFFSET * scale))), text, font=font, fill=(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">77</span>))  <span class="comment"># 黑色 40% 不透明度的阴影</span></span><br><span class="line">draw.text((text_x - text_x_offset, text_y - text_y_offset), text, font=font, fill=(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>))  <span class="comment"># 白色</span></span><br><span class="line">r = Image.alpha_composite(combined, txt)</span><br><span class="line">draw = ImageDraw.Draw(r)</span><br><span class="line"></span><br><span class="line">r.save(<span class="string">"result.jpg"</span>, format=<span class="string">"JPEG"</span>, quality=<span class="number">95</span>)  <span class="comment"># 不设置quality的话会默认以 75 的质量保存，损失很多画质，95 是最大值。</span></span><br></pre></td></tr></table></figure><p>然后就开心的给设计师验收了。</p><p>然后就坑爹了。</p><p>在图片大的时候，比如 1080P 这么大的图，看着效果确实还行。但是在小图的时候图片中文字周围有不明的黑色锯齿。</p><p>例如这样 </p><p><img src="https://dn-0x01-io.qbox.me/2018-03-30%2015.07.40.jpg" alt="黑色锯齿"></p><p>原因不明。然后就网上搜抗锯齿的方案。stackoverflow 上看到一些方法，例如<a href="https://stackoverflow.com/questions/14350645/is-there-an-antialiasing-method-for-python-pil" target="_blank" rel="noopener">这里</a>。就是把图片先放大 2 倍，等比放大绘制完成之后，再缩小到 1/2，也就是原图大小，并在 pillow 里的 <code>resize</code> 方法添加 <code>filter=Image.ANTIALIAS</code>。</p><p>确实有不少效果，黑色锯齿少了很多，但是还是有，并且因为缩小，绘制出来的文字画质有损失。不能接受。</p><p>查到最后发现，原来直接在原图上绘制就不会有黑色锯齿。之前都是先生成一张透明的图层，在这个上面绘制完成之后，把原图和透明图合并。不知道为什么，在透明图上绘制白色的文字就会有黑色锯齿，在尺寸小的时候。于是就改了一下思路，全部直接在原图上进行绘制，不用透明图了。</p><p>但是又发现，绘制出来的问题，没有透明度了。崩溃。不知道为什么。就又改了一下思路，把需要透明度的黑色阴影在透明图上绘制，和原图贴合之后，再在原图上绘制不需要透明度的白色文字。这样就解决了问题。晕死。</p><p>其实同时还有另一个问题，就是品牌 logo，其实就是「知乎」两个字。设计师给我的是一个 svg 图，方便等比放大。但是搜了一圈，发现 Python 没有什么特别方便的，操作 svg 的库，不是依赖太大，就是用起来很麻烦，没什么人维护。就让设计师换了个思路，把 svg 图转成 ttf 字体文件，到时候一起用字体绘制多方便。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好久没写博客了。最近在做图片水印功能，本来觉得难度不大，照着 Pillow 文档随便搞搞就行了。没想到设计师验收的时候发现一堆坑。也许是学艺不精，没有仔细研究过 Pillow，只是随便看看文档做的，可能是我用的姿势不对才导致一堆坑。&lt;/p&gt;
&lt;p&gt;基本需求是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;前面一个品牌 logo&lt;/li&gt;
&lt;li&gt;后面一个 @用户名，用思源黑体常规字重的字体&lt;/li&gt;
&lt;li&gt;有投影效果&lt;/li&gt;
&lt;li&gt;整体大小和图片宽度成比例&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;首先去 Pillow 文档里找了个 &lt;a href=&quot;http://pillow.readthedocs.io/en/latest/reference/ImageDraw.html#example-draw-partial-opacity-text&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;example&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在网上查一些 blog 也都是这么写的，于是就照着写了一个基本的。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="pillow" scheme="https://0x01.io/tags/pillow/"/>
    
      <category term="水印" scheme="https://0x01.io/tags/%E6%B0%B4%E5%8D%B0/"/>
    
      <category term="watermark" scheme="https://0x01.io/tags/watermark/"/>
    
  </entry>
  
  <entry>
    <title>x86 软路由透明代理构建方案</title>
    <link href="https://0x01.io/2017/04/01/x86-%E8%BD%AF%E8%B7%AF%E7%94%B1%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86%E6%9E%84%E5%BB%BA%E6%96%B9%E6%A1%88/"/>
    <id>https://0x01.io/2017/04/01/x86-%E8%BD%AF%E8%B7%AF%E7%94%B1%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86%E6%9E%84%E5%BB%BA%E6%96%B9%E6%A1%88/</id>
    <published>2017-04-01T17:49:18.000Z</published>
    <updated>2020-05-28T04:41:33.625Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><p>网络配置：<br>    双网卡 + NAT（iptable）+ DHCP<br>DNS 解析防污染：<br>    <a href="https://github.com/shawn1m/overture" target="_blank" rel="noopener">overture</a>（解析）+ dnsmasq（缓存）<br>代理：<br>    shadowsocks（普通 Python 版即可）+ redsocks<br>透明代理：<br>    iptable + ipset（国内 IP 段）</p><a id="more"></a><h2 id="网络环境"><a href="#网络环境" class="headerlink" title="网络环境"></a>网络环境</h2><p>主机是安装了 Ubuntu 14.04 的 x86 机器。双网卡分别是对接外网的网卡 p2p1，分配 IP 是 2.3.3.3（瞎说的）；接内网的网卡 eth0，分配的 IP 是 192.168.3.1，也就是后面的 192.168.3.0/24 的子网的网关。</p><h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><h3 id="开启双网卡"><a href="#开启双网卡" class="headerlink" title="开启双网卡"></a>开启双网卡</h3><p>首先是装上双网卡肯定的。确保在系统里新装的网卡已经启用了，在 ifconfig 里能看到两个网卡。顺便记住并记牢接内外网的网卡的名字，我这里是内网 eth0，外网 p2p1。</p><p>接内网的网卡 eth0 可以自己配置静态 IP，这里不说了，网上一堆教程，无非就是在 <code>/etc/network/interfaces</code> 改配置。改完之后不知道怎么生效的就直接重启机器吧。</p><h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><p>先安装 DHCP 的服务器 <code>sudo apt-get install isc-dhcp-server</code>。然后配置 DHCP 网卡 <code>/etc/default/isc-dhcp-server</code> 将<code>INTERFACES=&quot;&quot;</code>配置为对应内网网卡。</p><p>配置 <code>/etc/dhcp/dhcpd.conf</code> 更新 DHCP 服务器相关参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">subnet 192.168.3.0 netmask 255.255.255.0 &#123;</span><br><span class="line">    &#x2F;&#x2F;当DHCP客户端主机启动网络时服务器能够分配给他的IP地址的范围</span><br><span class="line">    range 192.168.3.60 192.168.3.240;</span><br><span class="line">    &#x2F;&#x2F;客户端能使用该IP地址的时间,以秒计算</span><br><span class="line">    default-lease-time 86400;</span><br><span class="line">    max-lease-time 86400;</span><br><span class="line">    &#x2F;&#x2F;客户端默认网关</span><br><span class="line">    option routers 192.168.3.1;</span><br><span class="line">    &#x2F;&#x2F;不从一个网口向另一个网口转发 DHCP 请求</span><br><span class="line">    option ip-forwarding off;</span><br><span class="line">    &#x2F;&#x2F;设置客户端广播地址和子网掩码</span><br><span class="line">    option broadcast-address 192.168.3.255;</span><br><span class="line">    option subnet-mask 255.255.255.0;</span><br><span class="line">   &#x2F;&#x2F;设置客户端DNS服务器，防止被上层的 DNS 污染</span><br><span class="line">   option domain-name-servers 192.168.3.1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新启动 DHCP 服务 <code>sudo service isc-dhcp-server restart</code></p><h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h3><p>首先，修改配置文件 <code>/etc/sysctl.conf</code> 里的<code>net.ipv4.ip_forward=1</code>。要么取消注释，要么新加一行，然后 <code>sysctl -p</code> 让修改生效。</p><p>然后开始要动 iptables 了。iptables 这个东西很魔幻，遇到奇怪的坑很正常。</p><p>建议先 <code>sudo apt-get install iptables-persistent</code> 安装 <code>iptables-persistent</code> 来 save/reload/restart/restore 保存／重新加载／重启 iptable／重新加载配置。基本用法就是形如 <code>sudo service iptables-persistent save</code>。玩溜了之后就开始搞 NAT。规则如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXTIF&#x3D;&quot;p2p1&quot;</span><br><span class="line">INTIF&#x3D;&quot;eth0&quot;</span><br><span class="line">iptables -t nat -A POSTROUTING -o $EXTIF -j MASQUERADE</span><br><span class="line">iptables -A FORWARD -i $EXTIF -o $INTIF -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -A FORWARD -i $INTIF -o $EXTIF -j ACCEPT</span><br></pre></td></tr></table></figure><p>上面的 EXTIF 就是外网网卡，INTIF 就是内网网卡，不要搞错了。</p><p>正常情况下，save 配置并重启 iptables 之后，在 192.168.3.0/24 的子网里应该就可以连通外网了。</p><h2 id="DNS-解析防污染"><a href="#DNS-解析防污染" class="headerlink" title="DNS 解析防污染"></a>DNS 解析防污染</h2><p>接下来要解决 DNS 解析结果被污染的问题。这里的坑不多。</p><h3 id="overture"><a href="#overture" class="headerlink" title="overture"></a>overture</h3><p>overture 是一个 Go 写的 DNS 解析器，支持中国特色社会主义的 DNS 解析。坑不大，到 github 上下载对应系统和架构的二进制包，解压出来就行了。然后把二进制程序丢到 <code>/usr/local/bin</code> 里面，顺便创建一个配置文件目录 <code>/etc/overture</code>，然后把解压出来的其他文件放到配置文件目录里去。</p><p>我们的配置文件是让 overture 监听在 54 端口上，用来做 dnsmasq 的上游。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;BindAddress&quot;: &quot;:54&quot;,</span><br><span class="line">  &quot;PrimaryDNS&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;Name&quot;: &quot;DNSPod&quot;,</span><br><span class="line">      &quot;Address&quot;: &quot;119.29.29.29:53&quot;,</span><br><span class="line">      &quot;Protocol&quot;: &quot;udp&quot;,</span><br><span class="line">      &quot;SOCKS5Address&quot;: &quot;&quot;,</span><br><span class="line">      &quot;Timeout&quot;: 6,</span><br><span class="line">      &quot;EDNSClientSubnet&quot;: &#123;</span><br><span class="line">        &quot;Policy&quot;: &quot;disable&quot;,</span><br><span class="line">        &quot;ExternalIP&quot;: &quot;&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;AlternativeDNS&quot;:[</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;Name&quot;: &quot;OpenDNS&quot;,</span><br><span class="line">      &quot;Address&quot;: &quot;208.67.222.222:443&quot;,</span><br><span class="line">      &quot;Protocol&quot;: &quot;tcp&quot;,</span><br><span class="line">      &quot;SOCKS5Address&quot;: &quot;&quot;,</span><br><span class="line">      &quot;Timeout&quot;: 6,</span><br><span class="line">      &quot;EDNSClientSubnet&quot;:&#123;</span><br><span class="line">        &quot;Policy&quot;: &quot;disable&quot;,</span><br><span class="line">        &quot;ExternalIP&quot;: &quot;&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;Name&quot;: &quot;google&quot;,</span><br><span class="line">      &quot;Address&quot;: &quot;8.8.8.8:53&quot;,</span><br><span class="line">      &quot;Protocol&quot;: &quot;tcp&quot;,</span><br><span class="line">      &quot;Timeout&quot;: 6,</span><br><span class="line">      &quot;MinimumTTL&quot;: 0,</span><br><span class="line">      &quot;CacheSize&quot; : 0,</span><br><span class="line">      &quot;EDNSClientSubnet&quot;:&#123;</span><br><span class="line">        &quot;Policy&quot;: &quot;enable&quot;,</span><br><span class="line">        &quot;ExternalIP&quot;: &quot;&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;OnlyPrimaryDNS&quot;: false,</span><br><span class="line">  &quot;RedirectIPv6Record&quot;: true,</span><br><span class="line">  &quot;IPNetworkFile&quot;: &quot;&#x2F;etc&#x2F;overture&#x2F;ip_network_sample&quot;,</span><br><span class="line">  &quot;DomainFile&quot;: &quot;&#x2F;etc&#x2F;overture&#x2F;domain_sample&quot;,</span><br><span class="line">  &quot;DomainBase64Decode&quot;: true,</span><br><span class="line">  &quot;HostsFile&quot;: &quot;&#x2F;etc&#x2F;overture&#x2F;hosts_sample&quot;,</span><br><span class="line">  &quot;MinimumTTL&quot;: 0,</span><br><span class="line">  &quot;CacheSize&quot; : 0,</span><br><span class="line">  &quot;RejectQtype&quot;: [255]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面在 /etc/overture 的文件名自己对应修改。</p><p>至于 overture 怎么跑起来就见仁见智了。可以做 service 启动项，只不过我习惯用 supervisor 开机启动，因为配置文件简单好写。</p><p>到这里可以通过命令 <code>dig @127.0.0.1 -p 54 www.google.com</code> 看 overture 好使不。</p><h3 id="dnsmasq"><a href="#dnsmasq" class="headerlink" title="dnsmasq"></a>dnsmasq</h3><p>dnsmasq 我这里仅仅用来做缓存了，没有用其他功能。</p><p>先安装，<code>sudo apt-get install dnsmasq</code>。然后到 <code>/etc/dnsmasq.conf</code> 里改一发配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 不读取 &#x2F;etc&#x2F;resolv.conf或者其他文件，取消注释即可，这样就可以在本文件里配置上游服务器</span><br><span class="line">no-resolv</span><br><span class="line">no-poll</span><br><span class="line"># 添加上游服务器为overture，那个#54代表端口号，千万别删了。。。。</span><br><span class="line">server&#x3D;127.0.0.1#54</span><br><span class="line"># 在所有网卡上关闭 DHCP，用不着这个功能。如果有多个网卡那么一行一个。</span><br><span class="line"># 我的DHCP是交给了别的程序</span><br><span class="line">no-dhcp-interface&#x3D;eth0</span><br><span class="line">no-dhcp-interface&#x3D;p2p1</span><br><span class="line">cache-size&#x3D;15000 # 缓存DNS的数目</span><br></pre></td></tr></table></figure><p>重启 <code>sudo service dnsmasq restart</code></p><p>这里就可以简单的通过 <code>dig www.facebook.com</code> 选择一个以前没解析过的域名来看缓存生效么，第一次应该一两百毫秒，第二次开始就应该是 1-2 毫秒了。</p><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><h3 id="shadowsocks"><a href="#shadowsocks" class="headerlink" title="shadowsocks"></a>shadowsocks</h3><p>之所以选择 shadowsocks（Python版） 而不是 C语言版的 shadowsocks-libev，一个是 x86 机器性能不是问题；二是 shadowsocks-libev 3.0 版以后在密码库的依赖上越走越远，导致各种依赖、编译特别麻烦；三是我这里用 redsocks 来做 tcp 到 sockv5 的转换，所以用不到 ss-redir 之类的东西。</p><p>这里没什么好说的，启动一个 sslocal 就好了，也像上面一样在 supervisor 里启动。但是有个坑，似乎 DNS 的解析逻辑有问题，最好 shadowsocks 的配置文件的 server 写 IP 地址，不要写域名。</p><h3 id="redsocks"><a href="#redsocks" class="headerlink" title="redsocks"></a>redsocks</h3><p>redsocks 是用来把普通的 tcp 流量转成 sockv5 的一个东西，承接 tcp 流量，转到 sslocal 里，功能和 ss-redir 一样的。</p><p>先安装，<code>sudo apt-get install redsocks</code>。</p><p>然后改配置文件 <code>/etc/redsocks.conf</code>，把 redsocks 部分里面的 port 改成你 sslocal 监听的地址，一般是 1080 吧。如果有奇怪的问题，可以把里面的 ip 和 local_ip 改成 0.0.0.0。</p><p>UPDATE:</p><p>使用过程中遇到一个问题，用着用着莫名其妙的翻不了了。看系统日志发现 redsocks 的 fd 用完，于是修改 <code>/etc/init.d/redsocks</code> 文件，在里面添加一条 <code>ulimit -n 51200</code>。并且重启 redsocks 就好了。</p><h2 id="透明代理"><a href="#透明代理" class="headerlink" title="透明代理"></a>透明代理</h2><p>我的透明代理策略是国内 IP 不走代理，国外 IP 不管墙不墙都走代理。</p><h3 id="ipset"><a href="#ipset" class="headerlink" title="ipset"></a>ipset</h3><p>ipset 是用来建立一个 IP 地址段的集合。用来存国内 IP 段的。</p><p>先把国内 IP 段搞出来，最新版可以这么搞来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl &#39;http:&#x2F;&#x2F;ftp.apnic.net&#x2F;apnic&#x2F;stats&#x2F;apnic&#x2F;delegated-apnic-latest&#39; | grep ipv4 | grep CN | awk -F\| &#39;&#123; printf(&quot;%s&#x2F;%d\n&quot;, $4, 32-log($5)&#x2F;log(2)) &#125;&#39; &gt; chnroute.txt</span><br></pre></td></tr></table></figure><p>然后创建 ipset 并添加国内的 IP 段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ipset create chnroute hash:net</span><br><span class="line">cat chnroute.txt | sudo xargs -I ip ipset add chnroute ip</span><br></pre></td></tr></table></figure><h3 id="iptable"><a href="#iptable" class="headerlink" title="iptable"></a>iptable</h3><p>接下来就要把流量做相应的转发了。</p><p>不要无脑粘贴，看一下注释。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -N SHADOWSOCKS</span><br><span class="line"># 在 nat 表中创建新链</span><br><span class="line">iptables -t nat -A SHADOWSOCKS -p tcp --dport 23596 -j RETURN</span><br><span class="line"># 23596 是 ss 代理服务器的端口，即远程 shadowsocks 服务器提供服务的端口，如果你有多个 ip 可用,但端口一致，就设置这个</span><br><span class="line"></span><br><span class="line">iptables -t nat -A SHADOWSOCKS -d 123.456.789.111 -j RETURN</span><br><span class="line"># 123.456.789.111 是 ss 代理服务器的 ip, 如果你只有一个 ss服务器的 ip，却能选择不同端口,就设置此条</span><br><span class="line"></span><br><span class="line">iptables -t nat -A SHADOWSOCKS -d 0.0.0.0&#x2F;8 -j RETURN</span><br><span class="line">iptables -t nat -A SHADOWSOCKS -d 10.0.0.0&#x2F;8 -j RETURN</span><br><span class="line">iptables -t nat -A SHADOWSOCKS -d 127.0.0.0&#x2F;8 -j RETURN</span><br><span class="line">iptables -t nat -A SHADOWSOCKS -d 169.254.0.0&#x2F;16 -j RETURN</span><br><span class="line">iptables -t nat -A SHADOWSOCKS -d 172.16.0.0&#x2F;12 -j RETURN</span><br><span class="line">iptables -t nat -A SHADOWSOCKS -d 192.168.0.0&#x2F;16 -j RETURN</span><br><span class="line">iptables -t nat -A SHADOWSOCKS -d 224.0.0.0&#x2F;4 -j RETURN</span><br><span class="line">iptables -t nat -A SHADOWSOCKS -d 240.0.0.0&#x2F;4 -j RETURN</span><br><span class="line"># 过滤局域网段</span><br><span class="line"></span><br><span class="line">iptables -t nat -A SHADOWSOCKS -p tcp -m set --match-set chnroute dst -j RETURN</span><br><span class="line"># ipset 过滤国内 IP 段</span><br><span class="line"></span><br><span class="line">iptables -t nat -A SHADOWSOCKS -p tcp -j REDIRECT --to-ports 12345</span><br><span class="line"># 12345 是 redsocks 的监听端口</span><br><span class="line"></span><br><span class="line">iptables -t nat -I PREROUTING -p tcp -j SHADOWSOCKS</span><br><span class="line"># 在 PREROUTING 链前插入 SHADOWSOCKS 链,使其生效</span><br></pre></td></tr></table></figure><p>然后还是用 iptables-persistent 保存配置并重启 iptables。</p><p>至此就应该 OK 了，要是还有什么坑，就没法管了。</p><p>至于效果嘛，现在路由翻墙可以跑满我们家百兆带宽了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本架构&quot;&gt;&lt;a href=&quot;#基本架构&quot; class=&quot;headerlink&quot; title=&quot;基本架构&quot;&gt;&lt;/a&gt;基本架构&lt;/h2&gt;&lt;p&gt;网络配置：&lt;br&gt;    双网卡 + NAT（iptable）+ DHCP&lt;br&gt;DNS 解析防污染：&lt;br&gt;    &lt;a href=&quot;https://github.com/shawn1m/overture&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;overture&lt;/a&gt;（解析）+ dnsmasq（缓存）&lt;br&gt;代理：&lt;br&gt;    shadowsocks（普通 Python 版即可）+ redsocks&lt;br&gt;透明代理：&lt;br&gt;    iptable + ipset（国内 IP 段）&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="翻墙" scheme="https://0x01.io/tags/%E7%BF%BB%E5%A2%99/"/>
    
      <category term="shadowsocks" scheme="https://0x01.io/tags/shadowsocks/"/>
    
      <category term="软路由" scheme="https://0x01.io/tags/%E8%BD%AF%E8%B7%AF%E7%94%B1/"/>
    
  </entry>
  
  <entry>
    <title>Crypto101 阅读笔记（8）</title>
    <link href="https://0x01.io/2016/03/21/Crypto101-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%888%EF%BC%89/"/>
    <id>https://0x01.io/2016/03/21/Crypto101-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%888%EF%BC%89/</id>
    <published>2016-03-21T21:01:33.000Z</published>
    <updated>2020-05-28T04:41:33.625Z</updated>
    
    <content type="html"><![CDATA[<h2 id="密钥衍生函数"><a href="#密钥衍生函数" class="headerlink" title="密钥衍生函数"></a>密钥衍生函数</h2><p>密钥衍生函数（Key derivation function，KDF）通过接收一个密文，和一个可选的 salt 参数，生成另外的密文，也就是 key。</p><p>KDF 目前经常用户密码的存储方案。KDF 与普通的哈希加盐的密码存储方案相比，区别在于 KDF 通常会有一个很多次的迭代过程，尽可能的增加计算的时间消耗，以抵挡暴力破解。目前常用的 KDF 包括 PBKDF2、bcrypt、scrypt。优先选用 scrypt 和 bcrypt，如果没有这两个，PBKDF2 也是可以的。</p><h3 id="bcrypt"><a href="#bcrypt" class="headerlink" title="bcrypt"></a>bcrypt</h3><p>目前业界最常用的是 bcrypt。常用模式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> bcrypt</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>password = <span class="string">b"super secret password"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bcrypt.hashpw(password, bcrypt.gensalt(<span class="number">10</span>))</span><br><span class="line"><span class="string">'$2b$10$jN0BGbH1W/50V1mW/cLWeewfmp3d0zbnenrlDgii2M6nnFKfM5USC'</span></span><br></pre></td></tr></table></figure><p>生成的 hash 串，开头的 <code>$2b$</code> 是标准前缀，还有 <code>$2a$</code>、<code>$2y$</code> 等，起到类似于版本号的作用。目前的默认前缀是 <code>$2b$</code>。紧接着的 10 表示 2^10 次循环迭代。接着的 <code>jN0BGbH1W/50V1mW/cLWee</code> 128 bit，经过 base64 编码成 22 个字符，代表的是随机的 salt。随后的 <code>wfmp3d0zbnenrlDgii2M6nnFKfM5USC</code> 184 bit，base64 编码成 31 个字符，是密码的哈希。</p><p>之所以不使用常见的 MD5、SHA1、SHA256 之类的 hash 算法是因为常用的 hash 无法对抗暴力破解。在我的笔记本上，一个如上文的代码，当指数是 10 的时候，计算一次 bcrypt 大约花费 80 毫秒，指数是 12 的时候，花费 290 毫秒，指数是 14 的时候，花费 1.2 秒。与此相应的是，一次 md5 计算只花费了 30 微秒。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;密钥衍生函数&quot;&gt;&lt;a href=&quot;#密钥衍生函数&quot; class=&quot;headerlink&quot; title=&quot;密钥衍生函数&quot;&gt;&lt;/a&gt;密钥衍生函数&lt;/h2&gt;&lt;p&gt;密钥衍生函数（Key derivation function，KDF）通过接收一个密文，和一个可选的 sal
      
    
    </summary>
    
    
    
      <category term="Crypto" scheme="https://0x01.io/tags/Crypto/"/>
    
      <category term="PBKDF" scheme="https://0x01.io/tags/PBKDF/"/>
    
      <category term="bcrypt" scheme="https://0x01.io/tags/bcrypt/"/>
    
      <category term="scrypt" scheme="https://0x01.io/tags/scrypt/"/>
    
  </entry>
  
  <entry>
    <title>Crypto101 阅读笔记（7）</title>
    <link href="https://0x01.io/2016/03/17/Crypto101-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%887%EF%BC%89/"/>
    <id>https://0x01.io/2016/03/17/Crypto101-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%887%EF%BC%89/</id>
    <published>2016-03-17T22:44:57.000Z</published>
    <updated>2020-05-28T04:41:33.625Z</updated>
    
    <content type="html"><![CDATA[<h2 id="签名算法"><a href="#签名算法" class="headerlink" title="签名算法"></a>签名算法</h2><p>签名算法（Signature）是基于非对称加密的一种消息验证机制。一个数字签名用于证明其消息的可靠性真实性。一个合法的数字签名，可以让接收者有理由相信，这条消息是由一个已知的发送者创建的，并且这个发送者不能否认曾经发送这个消息，并且这个消息在传输过程中没有被篡改过。</p><p>常见的应用场景如软件包的签名。软件发布者在发布软件的同时会签署一个数字签名，这样使用软件的人就可以确认这个软件的真实性、可靠性。</p><p>签名算法的工作方式十分简单，对于一段需要签名的消息，首先使用某种数字摘要算法，即哈希算法算出摘要，然后使用非对称加密算法的密钥对消息的摘要进行加密。这个加密后的数据就是这段消息的数字签名。当接收方接收到消息之后，首先同样经过哈希算出摘要，然后使用数字签名的非对称加密算法的公钥，解开签名，然后比对两个哈希，即可得知是否是合法的。</p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>常用的签名算法有基于 RSA 系列的 RSA-PCKS#1 v1.5 和 RSA-PSS，和美国联邦标准的 DSA 及其衍生算法 ECDSA。其中 RSA-PCKS#1 v1.5 和 DSA 都比较老旧，不推荐使用。最推荐使用椭圆曲线数学体系的 ECDSA，其次是 RSA-PSS。</p><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>数字证书是签名算法和非对称加密的一种应用。</p><p>在一个通信过程中，为了证明自己的身份，最好的方式是提供自己的数字证书来证明。但是仅仅传输一个证书，还不足以证明，因为在传输过程中，这个证书也可能被中间人篡改、替换。所以需要引入一个第三方的权威机构 CA，来证明自己的身份，就如同现实中的公证处一般。</p><p>具体操作过程就是自己将一些证明信息和公钥发送给 CA，CA 经过一定的审核之后，计算出这段信息的数字签名。也就是通过特定的 Hash 算法算出摘要，然后用 CA 的私钥进行加密。这就是一个数字签名。服务端只需要把这个数字签名和自己的证书一起发给客户端。客户端接收到之后，拿到 CA 的公钥，解出信息的摘要，然后自己用相同的 Hash 算法计算摘要，比对两个摘要，如果相同，则说明验证通过。</p><p>更加详细的讲解可以参看<a href="https://segmentfault.com/a/1190000004199917#articleHeader4" target="_blank" rel="noopener">这篇文章</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;签名算法&quot;&gt;&lt;a href=&quot;#签名算法&quot; class=&quot;headerlink&quot; title=&quot;签名算法&quot;&gt;&lt;/a&gt;签名算法&lt;/h2&gt;&lt;p&gt;签名算法（Signature）是基于非对称加密的一种消息验证机制。一个数字签名用于证明其消息的可靠性真实性。一个合法的数字签
      
    
    </summary>
    
    
    
      <category term="Crypto" scheme="https://0x01.io/tags/Crypto/"/>
    
      <category term="阅读笔记" scheme="https://0x01.io/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Signature" scheme="https://0x01.io/tags/Signature/"/>
    
  </entry>
  
  <entry>
    <title>Crypto101 阅读笔记（6）</title>
    <link href="https://0x01.io/2016/03/16/Crypto101-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89/"/>
    <id>https://0x01.io/2016/03/16/Crypto101-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89/</id>
    <published>2016-03-16T22:09:08.000Z</published>
    <updated>2020-05-28T04:41:33.625Z</updated>
    
    <content type="html"><![CDATA[<h2 id="信息认证码"><a href="#信息认证码" class="headerlink" title="信息认证码"></a>信息认证码</h2><p>信息认证码（message authentication code，MAC），是一段比较短的比特数据，用来检查一段信息、消息的可靠性和完整性，也被称为 tag。一个 MAC 算法接收一段任意长度的消息和一个固定长度的密钥 key，产生 tag 标记。一个 MAC 算法也有一个对应的校验算法，通过接收消息、key 和 tag，告诉是否合法。</p><p>如果只是需要确定一段特定消息的可靠性和完整性，可以使用签名算法，这个在后面会介绍。目前可以简单的认为签名算法通常用在非对称加密中，这里的 MAC 通常用于对称加密。</p><p>如果只需要检验一段消息的完整性，那么使用 CRC 之类的校验码或者 SHA 之类的哈希函数，都可以做到。但是为了保证可靠性，当有人攻击的时候，如果消息被篡改，那么攻击这可以重新计算校验码或者哈希。所以 MAC 类方法都需要有一个别人都不知道的 key。</p><h3 id="MAC-Encrypt"><a href="#MAC-Encrypt" class="headerlink" title="MAC Encrypt"></a>MAC Encrypt</h3><p>MAC 和 Encrypt 有三种结合使用的方式。</p><ol><li>Encrypt-then-MAC：$ C = E(K_C, P), t = MAC(K_M, C)$。先将原文加密，然后计算密文的 MAC。然后把 C 和 t 一块发送出去。</li><li>MAC-then-Encrypt：$ t = MAC(K_M, P), C = E(K_C, P || t)$。先计算原文的 MAC，然后把原文和计算出来的 tag 和在一块，进行加密。最后只需要发送加密后的密文即可。</li><li>Encrypt-and-MAC：$ C = E(K_C, P), t = MAC(K_M, P) $ 分别计算密文和 tag，分别把密文和 tag 发送出去。</li></ol><p>总得说来，更推荐使用 Encrypt-then-MAC，优点在于收到 C 和 t 之后，可以先检验 t，如果不正确，就不用对 C 进行解密了。IPSec 就使用这个方式。MAC-then-Encrypt 也可以使用，但是收到密文之后，必须先全部解密出来之后，才能校验消息是否完整。TLS 早期使用这种方式。Encrypt-and-MAC 最差，通过 t 就可以暴露出原文的一些特征。同样的原文会得到同样的 t。SSH 使用这种方式。</p><h3 id="HMAC"><a href="#HMAC" class="headerlink" title="HMAC"></a>HMAC</h3><p>HMAC 是目前最常用，也是目前比较安全的一种 MAC 算法。他底层的哈希函数要求很低，哪怕是目前不是特别安全的 MD5 或者 SHA-0 都可以。HMAC 的工作示意如下图：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/7f/SHAhmac.svg/1024px-SHAhmac.svg.png?1458141613104" alt="hmac-sha1"></p><p>其中 i_pad 是 0x363636…3636，一个常量，o_pad 是 0x5c5c5c…5c5c，另一个常量。</p><h3 id="Authenticated-encrption-modes"><a href="#Authenticated-encrption-modes" class="headerlink" title="Authenticated encrption modes"></a>Authenticated encrption modes</h3><p>在通常的密码学应用中，保密性用加密实现，消息认证用 MAC 实现。这两种算法的配合方式，引发了很多安全漏洞，上述的 3 种方法 Encrypt-then-MAC、MAC-then-Encrypt 和 Encrypt-and-MAC ，后来发现，后两者都是有安全问题的，所以，2008年起，逐渐提出了用一个算法在内部同时实现 cipher+ MAC 的想法，称为 AEAD(Authenticated encryption with additional data)。 在AEAD这种概念里，cipher + MAC 被一个 AEAD 算法替换。</p><h4 id="AES-GCM"><a href="#AES-GCM" class="headerlink" title="AES-GCM"></a>AES-GCM</h4><p>目前网络上最常用的 AEAD 类算法就是 AES-GCM。互联网上大部分的 HTTPS 流量都依赖于这个算法。</p><p>与 AES-GCM 相似的还有个 Chacha20-Poly1305 算法。但是目前最常用的还是 AES-GCM，因为在 Intel 的 CPU 中有专门优化的硬件指令，所以 AES-GCM 依然比 Chacha20-Poly1305 快很多。但是在移动端，ARM 处理器上，Chacha20-Poly1305 就比 AES-GCM 快了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;信息认证码&quot;&gt;&lt;a href=&quot;#信息认证码&quot; class=&quot;headerlink&quot; title=&quot;信息认证码&quot;&gt;&lt;/a&gt;信息认证码&lt;/h2&gt;&lt;p&gt;信息认证码（message authentication code，MAC），是一段比较短的比特数据，用来检查一段信
      
    
    </summary>
    
    
    
      <category term="Crypto" scheme="https://0x01.io/tags/Crypto/"/>
    
      <category term="MAC" scheme="https://0x01.io/tags/MAC/"/>
    
      <category term="GCM" scheme="https://0x01.io/tags/GCM/"/>
    
      <category term="HMAC" scheme="https://0x01.io/tags/HMAC/"/>
    
  </entry>
  
  <entry>
    <title>Crypto101 阅读笔记（5）</title>
    <link href="https://0x01.io/2016/03/14/Crypto101-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89/"/>
    <id>https://0x01.io/2016/03/14/Crypto101-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89/</id>
    <published>2016-03-14T21:51:52.000Z</published>
    <updated>2020-05-28T04:41:33.625Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hash-函数"><a href="#Hash-函数" class="headerlink" title="Hash 函数"></a>Hash 函数</h2><p>hash 函数就是将任意长度的一个字符串映射到一个固定长度字符串的过程，也叫摘要。</p><p>密码学中的 hash 函数可以用来构建安全的消息认证算法、签名算法和随机数生成算法。对于密码学 hash 算法，我们希望以下三个事情是很难做的：</p><ol><li>修改一个消息却不改变哈希值；</li><li>对于一个给定的哈希值来构造一个消息；</li><li>找到两个具有相同哈希值的消息；</li></ol><p>对于第一个性质，通常就是所谓的雪崩效应。哪怕仅仅修改了原消息的一个 bit，也会导致最后的哈希摘要产生巨大的变化。</p><p>第二个特性就是单向性。通过消息算出哈希非常容易，但是根据哈希找出原摘要十分的困难。</p><p>第三个特性就要求哈希函数耐碰撞。</p><p>常见的 Hash 函数包括 MD5、SHA-1、SHA-2 和 SHA-3。MD5 和 SHA-1 最常见，但是已经不是那么的安全了。推荐使用 SHA-2。</p><h3 id="密码存储"><a href="#密码存储" class="headerlink" title="密码存储"></a>密码存储</h3><p>通常业务是不会直接把密码存储到数据库中的。一旦数据库泄露，所有用户的密码就会泄露。通常都会把用户的密码进行 Hash 之后再存储到数据库中。校验用户密码的时候只要比对 Hash 值是否相同即可。</p><p>但是对于仅仅将密码进行 MD5 或者 SHA-1 的一次 Hash 之后存储也是不安全的。尽管攻击者不能根据哈希值算出原密码，但是攻击者可以构造一个叫做彩虹表的结构。彩虹表中存储了大量常用字符串和其 Hash 的映射关系。那么就可以根据 Hash 值反向查找到原密码了。</p><p>对于彩虹表，通常采用一种叫加盐的方式。对于用户的密码，进行 Hash 之前先将其和一个随机字符串结合之后再 Hash。如果盐使用不当的话，依然无法保证安全性。比如全局使用一个固定的盐，那么彩虹表只需要根据这个固定的盐再重新算一次就好了。盐一定要保证每个密码都是随机的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Hash-函数&quot;&gt;&lt;a href=&quot;#Hash-函数&quot; class=&quot;headerlink&quot; title=&quot;Hash 函数&quot;&gt;&lt;/a&gt;Hash 函数&lt;/h2&gt;&lt;p&gt;hash 函数就是将任意长度的一个字符串映射到一个固定长度字符串的过程，也叫摘要。&lt;/p&gt;
&lt;p&gt;密
      
    
    </summary>
    
    
    
      <category term="Crypto" scheme="https://0x01.io/tags/Crypto/"/>
    
      <category term="现代密码学" scheme="https://0x01.io/tags/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="阅读笔记" scheme="https://0x01.io/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
      <category term="hash" scheme="https://0x01.io/tags/hash/"/>
    
  </entry>
  
  <entry>
    <title>Crypto101 阅读笔记（4）</title>
    <link href="https://0x01.io/2016/03/06/Crypto101-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/"/>
    <id>https://0x01.io/2016/03/06/Crypto101-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/</id>
    <published>2016-03-06T17:03:43.000Z</published>
    <updated>2020-05-28T04:41:33.625Z</updated>
    
    <content type="html"><![CDATA[<h2 id="公钥加密"><a href="#公钥加密" class="headerlink" title="公钥加密"></a>公钥加密</h2><p>公开密钥加密（public-key cryptography），也称为非对称加密（asymmetric cryptography）。在这种方法中，需要一对密钥，一个是私钥，另一个是公钥。这两个密钥是数学相关，用某用户密钥加密后所得的信息，只能用该用户的解密密钥才能解密。如果知道了其中一个，并不能计算出另外一个。因此如果公开了一对密钥中的一个，并不会危害到另外一个的秘密性质。称公开的密钥为公钥；不公开的密钥为私钥。</p><p>最早公开的公钥加密算法，也同时是至今依然最常用的就是 RSA。</p><p>事实上有三类算法和公钥加密相关，一个是前面说到的密钥交换算法，二个就是 RSA 这种加密算法，三个是数字签名算法。</p><p>为什么一直使用 RSA 来加密，还一定要使用前面提到的 AES 之类的对称密钥加密？是因为 RSA 比 AES 之类的对称密钥加密，要慢上几百上千倍。</p><h3 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h3><p>首先随机选择两个大质数 $p$ 和 $q$，然后把他们相乘，得到 $N$，这个是可以公开的。然后再选择一个加密指数 $e$，这个通常是 3 或者 65537，这个指数是公开的。然后 $(N, e)$ 组合就是公钥。使用公钥将明文 M 加密成密文 C 过程如下：</p><p>$$C \equiv M^e ; (\bmod N)$$</p><p>对于解密的过程，你需要一个解密指数 $d$。利用 $p$ 和 $q$ 很容易计算出 $d$。这个过程涉及到一定的数学理论。解密过程如下：</p><p>$$M \equiv C^d ; (\bmod N)$$</p><p>RSA 的安全性建立在 $d$ 很难被逆向计算出来。</p><p>对于 RSA 的攻击，从理论上而言，由于尚未发现多项式时间里能够分解质因数的方法，所以还是安全的。但是量子计算机的出现，增加了从量子算法上破解 RSA 的可能。目前常见的破解方式还是实现上。比如 Python 的一个叫 Salt 的库，由于使用加密指数 $e$ 为 1，就导致了 $C = M$ 的情况。</p><p>目前通过暴力的方式破解 RSA 达到了 768 位，大大威胁了 1024 bit 密钥的安全性。所以目前推荐密钥至少要有 2048 位。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;公钥加密&quot;&gt;&lt;a href=&quot;#公钥加密&quot; class=&quot;headerlink&quot; title=&quot;公钥加密&quot;&gt;&lt;/a&gt;公钥加密&lt;/h2&gt;&lt;p&gt;公开密钥加密（public-key cryptography），也称为非对称加密（asymmetric cryptograp
      
    
    </summary>
    
    
    
      <category term="Crypto" scheme="https://0x01.io/tags/Crypto/"/>
    
      <category term="现代密码学" scheme="https://0x01.io/tags/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="阅读笔记" scheme="https://0x01.io/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
      <category term="RSA" scheme="https://0x01.io/tags/RSA/"/>
    
  </entry>
  
  <entry>
    <title>Crypto101 阅读笔记（3）</title>
    <link href="https://0x01.io/2016/03/05/Crypto101-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/"/>
    <id>https://0x01.io/2016/03/05/Crypto101-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/</id>
    <published>2016-03-05T19:44:05.000Z</published>
    <updated>2020-05-28T04:41:33.625Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Diffie-Hellman-密钥交换"><a href="#Diffie-Hellman-密钥交换" class="headerlink" title="Diffie-Hellman 密钥交换"></a>Diffie-Hellman 密钥交换</h2><p>在前一篇流加密里面介绍到，加密解密的双方需要有一个 key，需要保证不能泄露这个 key。那么双方要如何在不泄露的情况下都知道这个 key 呢。</p><p>Diffie-Hellman 密钥交换算法就是为了解决，通信双方，在一个不安全的通信环境里，在双方互相不认识的情况下，最终能协商出一个只有双方知道的值。</p><p>在这里恭喜 Diffie 和 Hellman 两人，前两天刚凭借这个密钥交换算法获得了 2015 年度的图灵奖。</p><p>Diffie-Hellman 最核心的思想就是利用某些某个方向计算很容易，但是反反向计算非常难的数学。</p><h3 id="数学解释"><a href="#数学解释" class="headerlink" title="数学解释"></a>数学解释</h3><p>首先，对于 $y \equiv g^x \quad (\bmod p)$ 这个等式中，知道 g、x、p 是很容易计算出 y 来的。但是知道 y、g、p 的情况下，算出 x 来却十分困难。所以，利用这个等式，我们就可以构建一个密钥协商的过程。</p><p>首先，通信的双方 Alice 和 Bob 分别选择一个随机数 $r_A$ 和 $r_B$，然后分别计算他们自己的：</p><p>$$ m_A = g^{r_A} \quad (\bmod p)$$</p><p>$$ m_B = g^{r_B} \quad (\bmod p)$$</p><p>然后 Alice 和 Bob 分别把自己算出来的 $m_A$ 和 $m_B$ 发送给对方。在这个发送的过程中，所有的通信数据都可以被 Eve 看到。所以 Eve 是知道 $m_A$ 和 $m_B$ 的。但是由于反方向计算十分困难，所以 Eve 无法反推出 $r_A$ 和 $r_B$。</p><p>Alice 和 Bob 分别接收到对方的 $m_B$ 和 $m_A$ 后。在对方发过来的数据的基础上，带入自己的随机数，例如对于 Bob 会计算：</p><p>$$ S = (g^{r_A}) ^ {r_B} \quad (\bmod p) $$</p><p>对于 Alice 会计算：</p><p>$$ S = (g^{r_B}) ^ {r_A} \quad (\bmod p) $$</p><p>尽管计算顺序不一样，但是最后的结果是一样的，$(g^{r_B}) ^ {r_A} \quad (\bmod p) = (g^{r_A}) ^ {r_B} \quad (\bmod p)$。这个 S 就是最后协商的密钥。</p><h3 id="椭圆曲线"><a href="#椭圆曲线" class="headerlink" title="椭圆曲线"></a>椭圆曲线</h3><p>Diffie-Hellman 还可以利用椭圆曲线（Elliptic curve），就是所说的 ECDH。</p><p>椭圆曲线密码学（ECC），基于椭圆曲线数学，作为程序员的我并不能看懂。</p><p>ECC 相比较而言的优势在于获得相同的安全性的时候，相对于上面的基于离散对数的方式，所需要的 key 的长度更小，所以计算速度会更快。</p><h3 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h3><p>Diffie-Hellman 算法并不能识别交换双方的身份。所以在交换密钥的过程中，可能会被中间人攻击。比如 Mallory 在 Alice 和 Bob 中间，分别和 Alice、Bob 进行密钥交换，那么 Mallory 还是可以分别得到两个人的 key。</p><p>为了解决这个问题，需要引入证书体系，将在后面介绍。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Diffie-Hellman-密钥交换&quot;&gt;&lt;a href=&quot;#Diffie-Hellman-密钥交换&quot; class=&quot;headerlink&quot; title=&quot;Diffie-Hellman 密钥交换&quot;&gt;&lt;/a&gt;Diffie-Hellman 密钥交换&lt;/h2&gt;&lt;p&gt;在前
      
    
    </summary>
    
    
    
      <category term="Crypto" scheme="https://0x01.io/tags/Crypto/"/>
    
      <category term="现代密码学" scheme="https://0x01.io/tags/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="阅读笔记" scheme="https://0x01.io/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Diffie-Hellman" scheme="https://0x01.io/tags/Diffie-Hellman/"/>
    
  </entry>
  
  <entry>
    <title>Crypto101 阅读笔记（2）</title>
    <link href="https://0x01.io/2016/03/05/Crypto101-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/"/>
    <id>https://0x01.io/2016/03/05/Crypto101-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/</id>
    <published>2016-03-05T17:09:07.000Z</published>
    <updated>2020-05-28T04:41:33.625Z</updated>
    
    <content type="html"><![CDATA[<h2 id="流加密"><a href="#流加密" class="headerlink" title="流加密"></a>流加密</h2><p>流加密（Stream Cipher）是对称密钥加密算法的一种，用来加密比特流。</p><p>流加密算法有两种，一种是利用块加密算法，利用某种工作模式，加密比特流；另一种从设计就是为了比特流考虑的算法。</p><h3 id="ECB-模式"><a href="#ECB-模式" class="headerlink" title="ECB 模式"></a>ECB 模式</h3><p>利用前一篇里面的块加密算法，很容易构想出一个原始简单的流加密算法。就是把比特流分割成一个个的具有块大小的数据块，然后对每一块分别使用块加密算法进行加密。</p><p>这种方式叫做 ECB（Electronic Code Book mode） 模式。这种加密模式最大的问题是相同的原明文块会被转变成相同的加密块。</p><h3 id="CBC-模式"><a href="#CBC-模式" class="headerlink" title="CBC 模式"></a>CBC 模式</h3><p>CBC 模式，Cipher Block Chining。CBC 模式就是明文数据块在加密之前会和前一个加密过得到的密文块进行异或运算。这个模式的问题是第一个明文块，没有前一个加密块。所以要引入一个 IV（Initialization Vector），初始化向量作为最初的加密块使用。IV 必须随机，不可预测，但没必要加密，重要的是不可预测。</p><p><img src="https://dn-0x01-io.qbox.me/CBC_encryption.png" alt="CBC_encryption"></p><p><img src="https://dn-0x01-io.qbox.me/CBC_decryption.png" alt="CBC_decryption.png"></p><p>与 CBC 模式很相似的模式还有 CFB 和 OFB 模式。</p><h3 id="CBC-模式下基于可预测-IV-的攻击"><a href="#CBC-模式下基于可预测-IV-的攻击" class="headerlink" title="CBC 模式下基于可预测 IV 的攻击"></a>CBC 模式下基于可预测 IV 的攻击</h3><p>在 AES 系统中，IV 通常都是可以从密文 C 中读到的。</p><p>一种常用的 AESCipher 的 Python 实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto <span class="keyword">import</span> Random</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AESCipher</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">( self, key )</span>:</span></span><br><span class="line">        self.key = key</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">( self, raw )</span>:</span></span><br><span class="line">        raw = pad(raw)</span><br><span class="line">        iv = Random.new().read( AES.block_size )</span><br><span class="line">        cipher = AES.new( self.key, AES.MODE_CBC, iv )</span><br><span class="line">        <span class="keyword">return</span> base64.b64encode( iv + cipher.encrypt( raw ) ) </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">( self, enc )</span>:</span></span><br><span class="line">        enc = base64.b64decode(enc)</span><br><span class="line">        iv = enc[:<span class="number">16</span>]</span><br><span class="line">        cipher = AES.new(self.key, AES.MODE_CBC, iv )</span><br><span class="line">        <span class="keyword">return</span> unpad(cipher.decrypt( enc[<span class="number">16</span>:] ))</span><br></pre></td></tr></table></figure><p>其中 IV 都是可以直接知道的。但是 IV 可知并不是什么问题，主要的问题是，IV 要不可被预知。</p><p>假设某条加密过的数据 $C_1$ 的 IV 是 $IV_a$ 可知，针对我们即将输入进去的数据的 IV 我们可预知，即 $IV_m$，我们可构造明文数据 $P_m = IV_m \oplus IV_a \oplus G$，其中，G 是我们猜测的 C1 的原文。</p><p>然后由 </p><p>$$<br>C_m = E(k, IV_m \oplus P_m) \<br>= E(k, IV_m \oplus(IV_m \oplus IV_a \oplus G)) \<br>= E(k, IV_a \oplus G)<br>$$</p><p>这里通过比较 $C_m$ 和 $C_1$，可以验证对于 $C_1$ 猜测的原文 G 是否正确。</p><h3 id="CBC-模式下把-key-用作-IV-的攻击"><a href="#CBC-模式下把-key-用作-IV-的攻击" class="headerlink" title="CBC 模式下把 key 用作 IV 的攻击"></a>CBC 模式下把 key 用作 IV 的攻击</h3><p>把 key 用作 IV 是不安全的。</p><p>假设 Alice 的明文 P 包含三个 block，分别为 $P_1 P_2 P_3$，在 CBC 模式下用 key 加密，并且 IV 也是 key。得到的密文 C 为 $C_1 C_2 C_3$ 发送给了 Bob。</p><p>在 Bob 接收到密文之前，Mallory 截获了密文。然后把密文篡改成 $C^{‘} = C_1ZC_1$，其中 Z 是全 0 的一个块。当 Bob 接收到被篡改过的密文并解密 $C^{‘}$ 之后，得到三个明文串 $P^{‘}_1$、$P^{‘}_2$ 和 $P^{‘}_3$。</p><p>$$P^{‘}_1 = D(k, C_1) \oplus IV = D(k, C_1) \oplus k = P_1 $$</p><p>$$P^{‘}_2 = D(k, Z) \oplus C_1 = R$$</p><p>$$P^{‘}_3 = D(k, C_1) \oplus Z = D(k, C_1) = P_1 \oplus IV$$</p><p>其中 R 是一个无所谓的串。</p><p>到此，Mallory 在得知 $P^{‘}_1$、$P^{‘}_2$ 和 $P^{‘}_3$ 的情况下，就可以推算出 IV，由于 key 就是 IV，所以就推算出了 key。</p><p>到这里我有个疑惑，Mallory 是怎么得知 $P^{‘}_1$、$P^{‘}_2$ 和 $P^{‘}_3$。然后发现书中这样的一句话 “Under the chosen-ciphertext attack assumption”。这句话的意思是，攻击者可以通过给定某一个特定的密文 C 给解密者并且获得对应解密后的明文结果。通常是利用解密端软件的某些 bug 或者漏洞。所以这里 Mallory 是可以拿到对应的 $P^{‘}_1$、$P^{‘}_2$ 和 $P^{‘}_3$ 的。所以说，这种漏洞的利用还是比较难的。</p><h3 id="Padding"><a href="#Padding" class="headerlink" title="Padding"></a>Padding</h3><p>Padding 就是填充的意思。</p><p>在 CBC 模式下，假设了每个加密块都是块加密算法的 block size 大小。但事实上，真正的数据流的长度是不定的。那么对于最后一块数据，长度不足一个 block 时候，就需要在末尾填充一些其他数据来满足长度要求。这个就是 Padding。</p><p>最简单的思维是，填充某个固定的字节，例如 0。问题是，无法区分填充字节和原来的数据。</p><p>更好，更常用的方法是 PKCS#5/PKCS#7。基本思想是，对于后面少几个字节，就把几全部填充进去。例如一个 8 个字节的 block，原始数据是 12 34 45，差 5 个字节。那么就填充成 12 34 45 05 05 05 05 05。当某个数据刚好是 block 的整数倍，不需要填充时，则在最后面填充一整个 block。</p><h3 id="CBC-Padding-attack"><a href="#CBC-Padding-attack" class="headerlink" title="CBC Padding attack"></a>CBC Padding attack</h3><p>使用 Padding attack 只需要两点，一段需要解密的密文 $C_i$，和一个可以响应 Padding 是否合法的目标程序。这里假设填充方法是上面说的 PKCS#5/PKCS#7。</p><p>首先攻击者构造一个随机串 $R = r_1,r_2,r_3…r_b$。然后，攻击者不停的尝试随机串 $R$ 的最后一个字符 $r_b$，目的是得到一个填充合法的结果。最差的情况是使得最后的明文串 $P_i$ 的最后一位 $P_b$ 是 01。根据上述 PKCS 的填充原理，01 必然是一个合法的填充结果。</p><p><img src="https://dn-0x01-io.qbox.me/CBC_Padding_attack.png" alt="CBC_Padding_attack.png"></p><p>这时我们得到填充合法的结果，我们有此时的随机串 $R$。但是并不知道填充的位数。但是可以知道的是，$P_i$ 的末尾必然是 </p><ul><li>$01$</li><li>$02\ 02$</li><li>$03\ 03\ 03$</li><li>… 这些情况。</li></ul><p>当然，从概率上而言，结尾是 $01$ 的可能性最大。</p><p>这里，我们假设最后的明文 $P_i = p_0p_1p_2p_3p_4030303$，其中 $p_0p_1p_2p_3p_4$ 是什么并不会影响我们进行填充正确性的检验。</p><p>所以我们从 $r_0$ 开始尝试变动，这样会导致最后的 $P_i = p^{‘}_0p_1p_2p_3p_4030303$。但是这样并不会影响我们进行填充正确性的检验。所以我们可以继续变动下一位 $r_1$，这样一直下去，直到填充正确性检验失败，我们就可以知道有多少位的填充 padding。从实际工作角度，我们或许没必要猜测是几位。我们就假定末尾是 01。当填充正确性检验通过的时候，我们不知道最后实际是几位，但是我们只需要变动一下倒数第二位，一旦校验失败，则说明 Padding 一定不是 01，这时我们不管他，继续尝试 $r_0$，直到能说明 Pading 是 01 为止。</p><p>接下来，我们假设最后的填充是 $01$，这是最坏的情况。</p><p>那么就有 $D(C_i)[b] \oplus r_b = 01$，这样我们可以计算出 $D(C_i)[b]$，即$C_i$被算法 D 解密之后的中间结果的最后一位。要注意这个中间结果，我们做这么多，目的就是这个中间结果，这个中间结果是不会变动的。</p><p>接下来我们去尝试倒数第二位。首先，根据上面的等式，我们可以推出 $D(C_i)[b] \oplus r_b  \oplus 01 \oplus 02 = 01 \oplus 01 \oplus 02 = 02$，也就是让 $r_b = r_b  \oplus 01 \oplus 02$，这时最后的填充位就变成了 02，这样，我们去暴力尝试 R 的倒数第二位，使得最后填充检验通过。这时，我们就可以得到$D(C_i)[b-1]$，也就是这个中间结果的倒数第二位。不断重复这个过程，我们可以得到整个中间结果串 $D(C_i)$。</p><p>这时，我们拿出密文 $C_i$ 的前一个密文串 $C_{i-1}$，根据 CBC 的工作模式，这里 $C_{i-1} \oplus C_i = P_i$。就这样，我们得到了解密后的结果 $P_i$。然后重复整个过程，我们可以解出所有的明文，除了第一块，因为我们不知道 IV。</p><h3 id="RC4"><a href="#RC4" class="headerlink" title="RC4"></a>RC4</h3><p>RC4，十分简单，但是已经被攻破。而且很快，13.9 cycles/bit。AES-128 CTR 模式是 12.6 cycles/bit，CBC 模式是 16 cycles/bit。</p><h3 id="Salsa20"><a href="#Salsa20" class="headerlink" title="Salsa20"></a>Salsa20</h3><p>Salsa20 是一种新的流加密算法。目前有两个版本，Salsa20/12 和 Salsa20/8。其中 12 和 8 表示循环次数，从原始的 20 降下来。与 Salsa20 相似的还有 ChaCha。</p><p>Salsa20 和 ChaCha 都非常快。</p><p>Salsa20 有个特点就是可以从任意一段进行加密解密。意味着算法可以并行。</p><h3 id="CTR-模式"><a href="#CTR-模式" class="headerlink" title="CTR 模式"></a>CTR 模式</h3><p>CTR 模式，也叫 counter 模式。</p><p>工作流程很简单，一个初始化的随机数 N，然后 N 和一个计数器连起来。和 key 加密后产生 key stream 再和明文 P 异或产生密文 C。每加密一块后计数器就加一。循环往复。</p><p><img src="https://dn-0x01-io.qbox.me/CTR_encryption.png" alt="CTR_encryption.png"></p><p><img src="https://dn-0x01-io.qbox.me/CTR_decryption.png" alt="CTR_decryption.png"></p><p>和 Salsa20 一样，可以从任意一段开始，也就是可以并行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;流加密&quot;&gt;&lt;a href=&quot;#流加密&quot; class=&quot;headerlink&quot; title=&quot;流加密&quot;&gt;&lt;/a&gt;流加密&lt;/h2&gt;&lt;p&gt;流加密（Stream Cipher）是对称密钥加密算法的一种，用来加密比特流。&lt;/p&gt;
&lt;p&gt;流加密算法有两种，一种是利用块加密算法
      
    
    </summary>
    
    
    
      <category term="Crypto" scheme="https://0x01.io/tags/Crypto/"/>
    
      <category term="现代密码学" scheme="https://0x01.io/tags/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="阅读笔记" scheme="https://0x01.io/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
      <category term="stream cipher" scheme="https://0x01.io/tags/stream-cipher/"/>
    
  </entry>
  
  <entry>
    <title>Crypto101 阅读笔记（1）</title>
    <link href="https://0x01.io/2016/03/04/Crypto101-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/"/>
    <id>https://0x01.io/2016/03/04/Crypto101-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/</id>
    <published>2016-03-04T23:06:15.000Z</published>
    <updated>2020-05-28T04:41:33.625Z</updated>
    
    <content type="html"><![CDATA[<p>Crypto101 是作为非数学专业，入门现代密码学不错的学习资料。本阅读笔记系列主要以一个程序员的视角来看待现代密码学。Crypto101 原文可以从官网下载到 <a href="https://www.crypto101.io/" target="_blank" rel="noopener">www.crypto101.io</a>。</p><h2 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h2><p>异或$\oplus$操作是密码学中非常重要的一个运算。</p><p>基本运算规则如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0⊕0&#x3D;0 </span><br><span class="line">1⊕0&#x3D;1 </span><br><span class="line">0⊕1&#x3D;1 </span><br><span class="line">1⊕1&#x3D;0</span><br></pre></td></tr></table></figure><p>通过以上可以推出一些常用的其他规律：</p><ol><li>异或运算可以任何顺序 $a \oplus b = b \oplus a$，即交换律</li><li>自己异或自己都是 0</li><li>任何比特异或 0 的结果都还是自己</li></ol><p>通过上述规律，可以推导出 $a \oplus b \oplus a = b$。通过这个原则，可以认为 a 异或 b 是加密过程，再异或 a 就是解密过程。</p><p>完美的加密模式是，明文的每个比特都和一个真随机的比特 key 进行异或。但是这样缺点也很明显，key 会和明文一样长。</p><h2 id="块加密"><a href="#块加密" class="headerlink" title="块加密"></a>块加密</h2><p>块加密（Block Cipher）即分组加密算法，允许对固定长度的块进行加密。</p><p>它使用加密函数 E，通过密钥 k 可以使得明文 P 变成密文 C：</p><p>$$ C = E(k, P) $$</p><p>明文和密文都是字节序列，这两者通常都拥有相同的长度，并且是被块加密算法规定好的一个长度，叫做块大小（block size）。所有可能的 key 被称为 keyspace，即键空间。</p><p>解密的过程相反，使用解密函数 D，通过和上面加密时一样的密钥 k 和密文 C，可以获得明文 P：</p><p>$$ P = D(k, C) $$</p><p>目前最常用的块加密算法是 AES。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Crypto101 是作为非数学专业，入门现代密码学不错的学习资料。本阅读笔记系列主要以一个程序员的视角来看待现代密码学。Crypto101 原文可以从官网下载到 &lt;a href=&quot;https://www.crypto101.io/&quot; target=&quot;_blank&quot; rel
      
    
    </summary>
    
    
    
      <category term="Crypto" scheme="https://0x01.io/tags/Crypto/"/>
    
      <category term="密码学" scheme="https://0x01.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="现代密码学" scheme="https://0x01.io/tags/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="阅读笔记" scheme="https://0x01.io/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
      <category term="xor" scheme="https://0x01.io/tags/xor/"/>
    
      <category term="异或" scheme="https://0x01.io/tags/%E5%BC%82%E6%88%96/"/>
    
      <category term="block cipher" scheme="https://0x01.io/tags/block-cipher/"/>
    
  </entry>
  
  <entry>
    <title>shadowsocks 源码阅读</title>
    <link href="https://0x01.io/2016/02/28/shadowsocks-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>https://0x01.io/2016/02/28/shadowsocks-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</id>
    <published>2016-02-28T16:53:53.000Z</published>
    <updated>2020-05-28T04:41:33.625Z</updated>
    
    <content type="html"><![CDATA[<p>本周末花了点时间阅读了一下 <a href="https://github.com/shadowsocks/shadowsocks" target="_blank" rel="noopener">shadowsocks</a> 2.8.1 版和 <a href="https://github.com/shadowsocks/shadowsocks-go" target="_blank" rel="noopener">shadowsocks-go</a> 1.1.4 版的源码。</p><p>原本工作原理是知道的，这里通过阅读源码，增加了对 eventloop 的网络模型和 Go 语言的 goroutine 模型的认知。两者比较起来，Python 版代码不记测试共计 4000 余行，Go 版本包括测试一共才 2000 多行代码。当然，主要原因是 Go 版本功能要少一点，比如 UDP 的支持，和 TCP Fast Open 特性支持。从理解上而言，Go 版本要远远好于 Python 版本。</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p><code>shadowsocks</code> 的基本工作原理并不复杂。shadowsocks 包括 local 和 server 两个程序。local 运行在用户自己的机器上，server 运行在墙外的服务器上。正常工作模式下，local 通常会监听本地 1080 端口，提供 socks v5 协议接口。在用户本机进程和 local 的 1080 端口建立 TCP 连接之后，首先会发送一个 hello 包，或者叫 handshake 握手包。local 程序接收到这个包之后，进行简单的包数据检查之后就返回一个确认包。本机进程收到确认的包之后，会再发送一个请求包，包的主要内容就是目标服务的地址和端口号。local 程序接收到请求包之后，会和 server 程序建立一个 TCP 连接，连接建立之后会把上面的目标服务的地址和端口号传给 server。这个连接是穿墙的关键，连接里面传输的数据都是经过加密的，最常用的就是 aes-256-cfb。local 程序会对请求包返回一个确认的包。然后本机进程就开始向 local 传输实际的数据，local 接收到之后加密继续传给 server。server 接收到之后把数据解密出来，然后和目标服务建立 TCP 连接，并把解密后的数据发送出去。然后接收数据就是上述的反过来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">                                        great firewall</span><br><span class="line">                                             +</span><br><span class="line">                                             |</span><br><span class="line">                                             |</span><br><span class="line">                    +----------+             |            +-----------+</span><br><span class="line">                    |          |             |            |           |</span><br><span class="line">   socks5           |  local   |    encryption            |  server   |   raw data</span><br><span class="line">&lt;------------&gt; 1080 |          | &lt;-----------+----------&gt; |           | &lt;-----------&gt;</span><br><span class="line">                    |          |             |            |           |</span><br><span class="line">                    |          |             |            |           |</span><br><span class="line">                    |          |             |            |           |</span><br><span class="line">                    |          |             |            |           |</span><br><span class="line">                    |          |             |            |           |</span><br><span class="line">                    |          |             |            |           |</span><br><span class="line">                    |          |             |            |           |</span><br><span class="line">                    |          |             |            |           |</span><br><span class="line">                    |          |             |            |           |</span><br><span class="line">                    |          |             |            |           |</span><br><span class="line">                    |          |             |            |           |</span><br><span class="line">                    |          |             |            |           |</span><br><span class="line">                    +----------+             |            +-----------+</span><br><span class="line">                                             |</span><br><span class="line">                                             |</span><br><span class="line">                                             |</span><br><span class="line">                                             +</span><br></pre></td></tr></table></figure><p>为了理解以上内容，强烈建议阅读一下 socks v5 协议的 <a href="https://www.ietf.org/rfc/rfc1928.txt" target="_blank" rel="noopener">RFC 1928</a>。不长，一共才 9 页，定义的包格式也很少。</p><h2 id="shadowsocks"><a href="#shadowsocks" class="headerlink" title="shadowsocks"></a>shadowsocks</h2><p>shadowsocks Python 版本主要包括 Eventloop、TCPRelay、UDPRelay 和 DNSResolver 这几个模块。我们主要介绍 TCP 的模式，UDP 不做过多介绍。</p><p>shadowsocks 主要的工作流程就是先进行配置处理，然后针对每个需要监听的端口建立一个 TCPRelay 和 UDPRelay，并添加到 eventloop 里。然后启动 eventloop 的循环。当 eventloop 接收到事件时，将事件分发，调用对应的 handle_event 进行处理。对于每个建立的客户端发起的 TCP 连接，都会新建一个 TCPRelayHandler 进行处理。</p><p>在这里，local 和 server 使用的是同一个 TCPRelay 类，他们的处理流程都统一了起来。但是就是因为如此，代码的理解上反而显的不是那么清晰。</p><h3 id="Eventloop"><a href="#Eventloop" class="headerlink" title="Eventloop"></a>Eventloop</h3><p>shadowsocks 最早期的版本是基于线程的模型处理并发连接的。由于种种原因，线程模型在频繁建立连接、高并发的情况下效率并不高。现在的版本是基于 eventloop 的处理模型。shadowsocks 里使用的 eventloop 是基于 epoll 模型的封装，把 select 和 kqueue 都封装成了 epoll 模型的接口。</p><p>eventloop 最重要的方法 run 里的逻辑，就是典型的 epoll 处理方式。这里强烈建议去理解一下 epoll 的工作模型。这里很简单，接收到 event 之后，调用对应的 handle_event 方法进行处理。</p><h3 id="TCPRelay"><a href="#TCPRelay" class="headerlink" title="TCPRelay"></a>TCPRelay</h3><p>TCPRelay 里有个概念就是 <code>_server_socket</code>，表示的是监听端口的 socket。然后看 TCPRelay 的 handle_event 逻辑就分为了两块，如果是 <code>_server_socket</code>，那么就只有客户端请求建立连接的事件，<code>_server_socket</code> 负责 accept 之后创建新的 TCPRelayHandler；如果不是，那么说明是客户端连接的读写事件，直接分发到对应的 TCPRelayHandler 调用 handle_event 进行处理。</p><p>在 <code>tcprelay.py</code> 这个文件最上方，有一段注释是描述的客户端连接建立的全部过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># as sslocal:</span><br><span class="line"># stage 0 SOCKS hello received from local, send hello to local</span><br><span class="line"># stage 1 addr received from local, query DNS for remote</span><br><span class="line"># stage 2 UDP assoc</span><br><span class="line"># stage 3 DNS resolved, connect to remote</span><br><span class="line"># stage 4 still connecting, more data from local received</span><br><span class="line"># stage 5 remote connected, piping local and remote</span><br><span class="line"></span><br><span class="line"># as ssserver:</span><br><span class="line"># stage 0 just jump to stage 1</span><br><span class="line"># stage 1 addr received from local, query DNS for remote</span><br><span class="line"># stage 3 DNS resolved, connect to remote</span><br><span class="line"># stage 4 still connecting, more data from local received</span><br><span class="line"># stage 5 remote connected, piping local and remote</span><br></pre></td></tr></table></figure><p>在 TCPRelayHandler 里，就是按照如下定义的 stage 的流程运行的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">STAGE_INIT &#x3D; 0</span><br><span class="line">STAGE_ADDR &#x3D; 1</span><br><span class="line">STAGE_UDP_ASSOC &#x3D; 2</span><br><span class="line">STAGE_DNS &#x3D; 3</span><br><span class="line">STAGE_CONNECTING &#x3D; 4</span><br><span class="line">STAGE_STREAM &#x3D; 5</span><br><span class="line">STAGE_DESTROYED &#x3D; -1</span><br></pre></td></tr></table></figure><p>先看 handle_event，里面的逻辑分成了 remote_sock 和 local_sock 两部分。先从 local_sock 开始。从客户端建立 TCP 连接之后，TCPRelayHandler 创建的时候，local_sock 就存在了，由于是客户端主动建立的连接，数据也都是客户端先发起的，所以先从 local_sock 的可读事件开始。记住，我们目前处于 STAGE_INIT 状态。在进入<code>_on_local_read</code>之后，紧守着<code>is_local</code>和<code>_stage</code>两个变量，就可以按照上面基本原理里面说的工作流程，将状态机运行起来了。</p><p>eventloop 模型比较让人讨厌的就是要不停的循环，然后进入各自的 handle_event 里去思考流程，比较麻烦。</p><h2 id="shadowsocks-go"><a href="#shadowsocks-go" class="headerlink" title="shadowsocks-go"></a>shadowsocks-go</h2><p>我们再来看看 Go 语言版本基于 goroutine 协程模型。</p><p>Go 语言版本的 local 和 server 也是十分相似的。</p><p>以 local 程序开始介绍。从 main 开始，处理各种配置的问题；然后到 run 运行起来，建立服务端的 socket，监听端口，循环接收来自客户端的连接请求；然后调用 handleConnection，并建立 goroutine，处理该连接的所有逻辑；在 handleConnection 里，所有逻辑就十分的简单了，全部是同步的方式，从上到下，一步一步的，最后建立上行和下行的两个 PipeThenClose。</p><p>main 就没什么好说的了，就是初始化配置，各种参数检查，然后跳到 run 开始运行。run 里面最主要的就是一个 for 的无限循环，不停的 accept 连接，然后 <code>go handleConnection(conn)</code> 开启新的 goroutine 协程并发的执行。</p><p>handleConnection 的逻辑分为 4 块。第一块就是到 handShake，无非就是按照 socks v5 协议要求接收一个包，返回一个包。第二块是到 getRequest，这里也是按照 socks v5 协议要求，接收一个包，这个包里主要的内容就是目标服务的地址和端口号。第三块是到 createServerConn，这里返回的 remote 是一个和远端的 server 建立的连接，是一个 <code>ss.Conn</code> 的类型，这个 Conn 类型是在标准库 net.Conn interface 的基础上进行的封装，实现了 Read 和 Write 接口。自己实现的 Read 接口会从 src 读数据之后并解密后返回，Write 接口会把数据加密后写入到 socket 中。最后第四块就是两个 PipeThenClose，自己这个 goroutine 和新开启的 goroutine 并发的从本地到远端、远端到本地的上下行的数据传输。</p><p>server 的执行流程和上述也是一样的，main 里面处理配置之后到 run 开始执行。run 里面无限循环接收请求，建立连接，然后<code>go handleConnection(ss.NewConn(conn, cipher.Copy()))</code> 开启新的 goroutine。需要注意的是这里传入的是 <code>ss.Conn</code> 类型的客户端连接，他的 Read 和 Write 接口是有解密和加密的逻辑的。handleConnection 方法的逻辑也十分相似了，除了没有第一步的握手阶段。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总得看来，shadowsocks 并不复杂。Python 版本的 eventloop 和 Go 版本的 goroutine，两种模型相比较，个人觉得 goroutine 明显更加容易理解。</p><p>在理解上述内容之前，需要读者对于 socket 编程、epoll 模型、socks v5 的协议内容和 Go 语言要有一定的了解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本周末花了点时间阅读了一下 &lt;a href=&quot;https://github.com/shadowsocks/shadowsocks&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;shadowsocks&lt;/a&gt; 2.8.1 版和 &lt;a href=&quot;https
      
    
    </summary>
    
    
    
      <category term="shadowsocks" scheme="https://0x01.io/tags/shadowsocks/"/>
    
      <category term="shadowsocks-go" scheme="https://0x01.io/tags/shadowsocks-go/"/>
    
      <category term="源码" scheme="https://0x01.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Let&#39;s Encrypt折腾记录</title>
    <link href="https://0x01.io/2015/12/26/Let-s-Encrypt%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/"/>
    <id>https://0x01.io/2015/12/26/Let-s-Encrypt%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/</id>
    <published>2015-12-26T09:08:09.000Z</published>
    <updated>2020-05-28T04:41:33.625Z</updated>
    
    <content type="html"><![CDATA[<p>久闻 Let’s Encrypt 的大名，一直没抽出空来折腾一下。刚好昨天看到下面这篇文章，晚上就折腾了一下。以下内容全部遵循这篇文章<a href="https://imququ.com/post/letsencrypt-certificate.html" target="_blank" rel="noopener"><code>Let&#39;s Encrypt，免费好用的 HTTPS 证书</code></a>的教程，在有些我自己遇到的坑的地方，做了一些修改和提醒。</p><h2 id="创建帐号"><a href="#创建帐号" class="headerlink" title="创建帐号"></a>创建帐号</h2><p>首先创建一个目录，例如 <code>/home/xxx/ssl</code>，用来存放各种临时文件和最后的证书文件。进入这个目录，创建一个 RSA 私钥用于 Let’s Encrypt 识别你的身份：</p><blockquote><p>openssl genrsa 4096 &gt; account.key</p></blockquote><h2 id="创建-CSR-文件"><a href="#创建-CSR-文件" class="headerlink" title="创建 CSR 文件"></a>创建 CSR 文件</h2><p>接着就可以生成 CSR（Certificate Signing Request，证书签名请求）文件了。在之前的目录中，再创建一个域名私钥（一定不要使用上面的账户私钥）：</p><blockquote><p>openssl genrsa 4096 &gt; domain.key</p></blockquote><p>PS：这里是创建了 4096 位的证书，为了一定的兼容性，我创建的是 2048 位的证书。</p><p>生成 CSR 时推荐至少把域名带 www 和不带 www 的两种情况都加进去，其它子域可以根据需要添加（目前一张证书最多可以包含 100 个域名）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -sha256 -key domain.key -subj &quot;&#x2F;&quot; -reqexts SAN -config &lt;(cat &#x2F;etc&#x2F;ssl&#x2F;openssl.cnf &lt;(printf &quot;[SAN]\nsubjectAltName&#x3D;DNS:yoursite.com,DNS:www.yoursite.com&quot;)) &gt; domain.csr</span><br></pre></td></tr></table></figure><p>执行这一步时，如果提示找不到 <code>/etc/ssl/openssl.cnf</code> 文件，应该是没有安装 <code>openssl</code> 库。</p><h2 id="配置验证服务"><a href="#配置验证服务" class="headerlink" title="配置验证服务"></a>配置验证服务</h2><p>我们知道，CA 在签发 DV（Domain Validation）证书时，需要验证域名所有权。传统 CA 的验证方式一般是往 <code>admin@yoursite.com</code> 发验证邮件，而 Let’s Encrypt 是在你的服务器上生成一个随机验证文件，再通过创建 CSR 时指定的域名访问，如果可以访问则表明你对这个域名有控制权。</p><p>首先创建用于存放验证文件的目录，例如：</p><blockquote><p>mkdir /home/xxx/www/challenges/</p></blockquote><p>PS：这里一定要开辟另外的一个目录，千万不要和上面的 ssl 的目录放在一起。因为这个目录下的文件会开发的互联网给别人访问的，如果也放在 ssl 目录下，你的一些私钥会被人扫描到的。</p><p>然后配置一个 HTTP 服务，以 Nginx 为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    server_name www.yoursite.com yoursite.com;</span><br><span class="line"></span><br><span class="line">    location &#x2F;.well-known&#x2F;acme-challenge&#x2F; &#123;</span><br><span class="line">        alias &#x2F;home&#x2F;xxx&#x2F;www&#x2F;challenges&#x2F;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个验证服务以后更新证书还要用到，需要一直保留。</p><h2 id="获取网站证书"><a href="#获取网站证书" class="headerlink" title="获取网站证书"></a>获取网站证书</h2><p>先把 acme-tiny 脚本保存到之前的 <code>ssl</code> 目录：</p><blockquote><p>wget <a href="https://raw.githubusercontent.com/diafygi/acme-tiny/master/acme_tiny.py" target="_blank" rel="noopener">https://raw.githubusercontent.com/diafygi/acme-tiny/master/acme_tiny.py</a></p></blockquote><p>指定账户私钥、CSR 以及验证目录，执行脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python acme_tiny.py --account-key .&#x2F;account.key --csr .&#x2F;domain.csr --acme-dir &#x2F;home&#x2F;xxx&#x2F;www&#x2F;challenges&#x2F; &gt; .&#x2F;signed.crt</span><br></pre></td></tr></table></figure><p>如果一切正常，当前目录下就会生成一个 <code>signed.crt</code>，这就是申请好的证书文件。<br>如果你把域名 DNS 解析放在国内，这一步很可能会遇到类似这样的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ValueError: Wrote file to &#x2F;home&#x2F;xxx&#x2F;www&#x2F;challenges&#x2F;oJbvpIhkwkBGBAQUklWJXyC8VbWAdQqlgpwUJkgC1Vg, but couldn&#39;t download http:&#x2F;&#x2F;www.yoursite.com&#x2F;.well-known&#x2F;acme-challenge&#x2F;oJbvpIhkwkBGBAQUklWJXyC8VbWAdQqlgpwUJkgC1Vg</span><br></pre></td></tr></table></figure><p>这是因为你的域名很可能在国外无法访问，可以找台国外 VPS 验证下。我的域名最近从 DNSPod 换到了阿里云解析，最后又换到了 <code>CloudXNS</code>，就是因为最近前两家在国外都很不稳定。如果你也遇到了类似情况，可以暂时使用国外的 DNS 解析服务商。</p><p>搞定网站证书后，还要下载 Let’s Encrypt 的中间证书。我在之前的文章中讲过，配置 HTTPS 证书时既不要漏掉中间证书，也不要包含根证书。在 Nginx 配置中，需要把中间证书和网站书合在一起：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget -O - https:&#x2F;&#x2F;letsencrypt.org&#x2F;certs&#x2F;lets-encrypt-x1-cross-signed.pem &gt; intermediate.pem</span><br><span class="line">cat signed.crt intermediate.pem &gt; chained.pem</span><br></pre></td></tr></table></figure><p>最终，修改 Nginx 中有关证书的配置并 reload 服务即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssl_certificate     &#x2F;home&#x2F;xxx&#x2F;ssl&#x2F;chained.pem;</span><br><span class="line">ssl_certificate_key &#x2F;home&#x2F;xxx&#x2F;ssl&#x2F;domain.key;</span><br></pre></td></tr></table></figure><h2 id="ERR-SPDY-INADEQUATE-TRANSPORT-SECURITY"><a href="#ERR-SPDY-INADEQUATE-TRANSPORT-SECURITY" class="headerlink" title="ERR_SPDY_INADEQUATE_TRANSPORT_SECURITY"></a>ERR_SPDY_INADEQUATE_TRANSPORT_SECURITY</h2><p>到了这一步，nginx 重新 reload 应该可以来着，但是我用浏览器访问的时候遇到了这样的错误。可能和我使用了 1.9.7 版本的 Nginx 有关。</p><p>解决方案是需要加上 <code>ssl_prefer_server_ciphers</code> 和 <code>ssl_ciphers</code> 这样的东西。ssl_ciphers 有各种各样的版本，复杂的、简单的，复杂的一般都是为了保持尽可能多的兼容性的情况下的安全性。我使用的是 <a href="https://mozilla.github.io/server-side-tls/ssl-config-generator/" target="_blank" rel="noopener">Mozilla SSL Configuration Generator</a> 中的 Intermediate 的配置。也有诸如 <a href="https://github.com/cloudflare/sslconfig/blob/master/conf" target="_blank" rel="noopener">CloudFlare</a> 的简单配置。</p><p>隐去一些自己的信息的 Nginx 配置如下。开启 http2 需要较新版的 Nginx 1.9.x 才行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 443 http2;</span><br><span class="line">        ssl on;</span><br><span class="line"></span><br><span class="line">        server_name youdomain.com www.yourdomain.com;</span><br><span class="line">        ssl_certificate     &#x2F;home&#x2F;xxx&#x2F;ssl&#x2F;chained.pem;</span><br><span class="line">        ssl_certificate_key &#x2F;home&#x2F;xxx&#x2F;ssl&#x2F;domain.key;</span><br><span class="line"></span><br><span class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">        ssl_ciphers &#39;ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:ECDHE-RSA-DES-CBC3-SHA:ECDHE-ECDSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA&#39;;</span><br><span class="line">        ssl_prefer_server_ciphers   on;</span><br><span class="line">        add_header Strict-Transport-Security max-age&#x3D;2592000;  # HSTS 特性自选</span><br><span class="line"></span><br><span class="line">        location &#x2F;.well-known&#x2F;acme-challenge&#x2F; &#123;</span><br><span class="line">                alias &#x2F;home&#x2F;xxx&#x2F;www&#x2F;challenges&#x2F;;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name yourdomain.com www.yourdomain.com;</span><br><span class="line">        return 301 https:&#x2F;&#x2F;yourdomain.com$request_uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置自动更新"><a href="#配置自动更新" class="headerlink" title="配置自动更新"></a>配置自动更新</h2><p>Let’s Encrypt 签发的证书只有 90 天有效期，但可以通过脚本定期更新。例如我创建了一个 renew_cert.sh，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">cd &#x2F;home&#x2F;xxx&#x2F;ssl&#x2F;</span><br><span class="line">python acme_tiny.py --account-key account.key --csr domain.csr --acme-dir &#x2F;home&#x2F;xxx&#x2F;www&#x2F;challenges&#x2F; &gt; signed.crt || exit</span><br><span class="line">wget -O - https:&#x2F;&#x2F;letsencrypt.org&#x2F;certs&#x2F;lets-encrypt-x1-cross-signed.pem &gt; intermediate.pem</span><br><span class="line">cat signed.crt intermediate.pem &gt; chained.pem</span><br><span class="line">service nginx reload</span><br></pre></td></tr></table></figure><p>这个脚本需要以 root 帐号运行，使用绝对路径比较保险。最后，修改 root 帐号的 crontab 配置，加入以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0 1 * * &#x2F;home&#x2F;xxx&#x2F;root_shell&#x2F;renew_cert.sh &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>这样以后证书每个月都会自动更新，一劳永逸。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;久闻 Let’s Encrypt 的大名，一直没抽出空来折腾一下。刚好昨天看到下面这篇文章，晚上就折腾了一下。以下内容全部遵循这篇文章&lt;a href=&quot;https://imququ.com/post/letsencrypt-certificate.html&quot; target=
      
    
    </summary>
    
    
    
      <category term="HTTPS" scheme="https://0x01.io/tags/HTTPS/"/>
    
      <category term="Let&#39;s Encrypt" scheme="https://0x01.io/tags/Let-s-Encrypt/"/>
    
      <category term="ERR_SPDY_INADEQUATE_TRANSPORT_SECURITY" scheme="https://0x01.io/tags/ERR-SPDY-INADEQUATE-TRANSPORT-SECURITY/"/>
    
  </entry>
  
  <entry>
    <title>DNS、DNSSEC、Anycast和BGP</title>
    <link href="https://0x01.io/2015/11/30/DNS%E3%80%81DNSSEC%E3%80%81Anycast%E5%92%8CBGP/"/>
    <id>https://0x01.io/2015/11/30/DNS%E3%80%81DNSSEC%E3%80%81Anycast%E5%92%8CBGP/</id>
    <published>2015-11-30T18:07:14.000Z</published>
    <updated>2020-05-28T04:41:33.625Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>本文属于 DNS 相关的进阶文章，需要读者对 DNS 的基础有所了解。基础文章可以看看<a href="http://selfboot.cn/2015/11/05/dns_theory/" target="_blank" rel="noopener">这篇</a>。</p><h2 id="DNSSEC"><a href="#DNSSEC" class="headerlink" title="DNSSEC"></a>DNSSEC</h2><p>DNSSEC（Domain Name System Security Extensions）是 DNS 协议的一个安全性拓展。其地位就相当于 HTTPS 于 HTTP。DNS 系统设计的时候，网络规模还很小，没有考虑到现在复杂的安全性问题。所以 DNS 的数据很容易被篡改。</p><h3 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h3><p>中间人攻击在中国是一种十分常见的 DNS 攻击技术。被某防火墙广泛应用。</p><p><img src="https://dn-0x01-io.qbox.me/dns-image01.jpg" alt="Man-in-the-middle attacks"></p><p>中间人攻击很容易理解，就是在用户的解析器和域名的解析服务器之间，有一个中间人，他会抢在解析服务器返回结果之前，抢先把一个错误的假结果伪装成原 DNS 请求的返回结果，然后由于 DNS 协议的缺陷，解析器会认为收到的第一个结果就是真的，抛弃后续收到的返回。</p><h3 id="DNS-投毒"><a href="#DNS-投毒" class="headerlink" title="DNS 投毒"></a>DNS 投毒</h3><p>DNS 投毒是促使 DNSSEC 标准尽快推进的一个动力。</p><p><img src="https://dn-0x01-io.qbox.me/dns-image03.jpg" alt="DNS poisoning"></p><p>由于 DNS 通常都是基于无连接的 UDP 协议的，并且由于上面说的，DNS 解析器会认为接收到的第一个结果就是真实的，而抛弃后续的结果。所以，DNS 投毒就是利用一大批的肉鸡，向解析器发送伪装的假结果，让解析器误把假结果当作是正确的返回。从而使得诱导用户访问到错误的地方。</p><h3 id="Resource-Records"><a href="#Resource-Records" class="headerlink" title="Resource Records"></a>Resource Records</h3><p>Resource Records 也就是所谓的资源记录，用于表示 DNS 请求的哪种类型的资源。其中最常用的是以下几种：</p><table><thead><tr><th>记录类型</th><th>含义</th></tr></thead><tbody><tr><td>A</td><td>主机的 IPv4 地址记录</td></tr><tr><td>AAAA</td><td>主机的 IPv6 地址记录</td></tr><tr><td>CNAME</td><td>一个域名的别名</td></tr><tr><td>MX</td><td>域名的邮件域记录</td></tr><tr><td>NS</td><td>域名的权威解析服务器的地址</td></tr></tbody></table><h3 id="DNSSEC-加密"><a href="#DNSSEC-加密" class="headerlink" title="DNSSEC 加密"></a>DNSSEC 加密</h3><p>DNSSEC 为了保证请求结果的正确性，是通过对请求的资源记录使用非对称加密算法进行加密，然后把公钥放到 DNS 的请求结果中，私钥由权威解析服务器自己保留。然后解析器在拿到结果的时候，使用拿到的公钥，解密出 DNS 请求，来确认结果的正确性。为了实现这样的目的，DNSSEC 增加了几种资源记录：</p><table><thead><tr><th>记录类型</th><th>含义</th></tr></thead><tbody><tr><td>DNSKEY</td><td>非对称加密算法中的公钥</td></tr><tr><td>DS</td><td>权威服务器使用的私钥的 hash</td></tr><tr><td>RRSIG</td><td>使用私钥对资源记录加密过的数据</td></tr><tr><td>KSK</td><td>用于解开 DNSKEY 资源记录使用的公钥</td></tr><tr><td>ZSK</td><td>用于解开其他资源记录使用的公钥</td></tr></tbody></table><h3 id="信任链"><a href="#信任链" class="headerlink" title="信任链"></a>信任链</h3><p>那么 DNSSEC 具体是如何利用上面的几种资源记录工作的呢。</p><p><img src="https://dn-0x01-io.qbox.me/dns-image00.jpg" alt="DNSSEC"></p><p>这是一个工作的信任链。假如我需要请求 example.com 的 A 记录，也就是想拿到它的  IPv4 地址。那么在 DNSSEC 体系中，我肯定需要拿到这个 A 记录的 RRSIG，也就是加密过的数据用于比较。为了解开这个加密过的数据，我肯定是得拿公钥。而在 DNSSEC 中，除了DNSKEY 公钥本身，其他资源记录都是使用 ZSK 进行加密的。所以这里我们需要拿到 ZSK 记录。同样的道理啊，ZSK 也是一种资源记录，和前面的 A 记录一样，为了保证我拿到的 ZSK 也是可信的，没有被篡改过的，我也得拿 DNSKEY ZSK 记录的 RRSIG，也就是加密数据。为了解开这个加密数据，我又得拿非对称加密算法中的公钥，这里我们为了解开 KEY，所以我们需要拿的就是 KSK 了。只要拿到这么些个数据，我们就可以解开所有被非对称加密算法加密过的数据，然后确保所有的数据的正确性了。</p><p>但是，这个 KSK 记录如何保证它的真实性呢？这里我们就不能继续在 example.com 的权威服务器里解决了，这里无法构成信任链，成了一个死循环。所以我们要请求 example.com 的上一层权威服务器，也就是 .com 的权威服务器，请求 example.com 的 KSK 的 hash 值，也就是上面提到的 DS 资源记录。通过比较这个 hash 值，我们就可以确定这个 KSK 的正确性。</p><p>当然，为了能够请求到正确的，未被篡改的 DS 记录，我们又得重复上述的过程，请求 DS 记录的 RRSIG 加密数据。 这样不断的重复上述过程，最终我们会如上图一样，一路走到根服务器，请求根服务器的 KSK。这样，信任链就走到根服务器的 KSK 记录了。而，全球十几个根服务器的 KSK 记录，是公开的，所有人都知道的，无法被篡改的，可信的。就这样，我们的信任链就建立起来了。</p><h2 id="Anycast"><a href="#Anycast" class="headerlink" title="Anycast"></a>Anycast</h2><p>Anycast 中文叫任播。其特性就是分布在全球的不同的服务器，使用同一个 IP 地址，然后通过动态路由协议，使得用户的请求会被路由到距离他们最近的一个服务器上去。通常用于实现 Public DNS 和 CDN。</p><p>Public DNS 就是我们经常见到的例如 114.114.114.114，或者 8.8.8.8 之类的 DNS 解析服务器。特点就是在全球各地，ping 这些服务器的延迟都非常低，都在几毫秒到三十几毫秒之间。</p><p>Anycast 就这么简单，全球各地部署多个机房，每个对外服务的机器都是用同一个 IP 地址，然后通过动态路由协议使得用户的请求可以被送到距离他们最近的服务器上去。</p><h2 id="BGP"><a href="#BGP" class="headerlink" title="BGP"></a>BGP</h2><p>到这里我们来讲讲上面 Anycast 中，是如何实现动态路由，使得用户的请求可以被路由到最近的服务器上去的。</p><h3 id="自治系统"><a href="#自治系统" class="headerlink" title="自治系统"></a>自治系统</h3><p>自治系统(AS)是指在一个实体管辖下的所有网络。通常比如中国电信是一个自治系统，中国联通是一个自治系统，阿里云的所有服务器是一个自治系统。</p><h3 id="边界网关协议"><a href="#边界网关协议" class="headerlink" title="边界网关协议"></a>边界网关协议</h3><p>BGP 就是边界网关协议，用于在自治系统间进行路由的协议。在自治系统内部，通常使用 RIP 和 OSPF 进行动态路由。RIP 由于历史原因，已经基本被 OSPF 替代。</p><p>现实的互联网，其实是两层网络组成的。我们平常接触到的网络是属于一个自治系统，是一个网状的结构。然后我们上一层，也就是在自治系统外，又有一个网络，也就是所谓的骨干网。</p><p>BGP 面对的就是一个个的自治系统之间的路由问题。BGP 是一种基于 TCP 协议的动态路由协议，他通过启动时和周围的其他 BGP 邻居建立 TCP 连接的方式交换路由数据。</p><p>BGP 的路由策略有 13 条之多，所以十分复杂。其中最容易理解，最简单的就是 AS_PATH 的概念。AS_PATH 就是自治系统之间的路径。通常而言，路径越短的，肯定越优先选择。</p><p>所以我们来谈谈，Anycast 是如何利用 BGP 实现动态路由到最近的服务器这件事情的。</p><p><img src="https://dn-0x01-io.qbox.me/dns-opendns-miami-s.jpg" alt="OpenDNS"></p><p>一个 Anycast 系统，通常都会申请一个 ASN，也就是一个自治系统编号，也就是自己就是一个自治系统。然后在全球的各个服务器上，运行 BGP 程序。比如上图的 Miami 的服务器，他会和自己附近的自治系统建立 BGP 邻居关系，宣告自己负责的 IP 网段。更新附近 AS 的路由信息。由于 Miami 的服务器，在地理位置上距离最下面的 AS64496 最近，所以他们之间建立了一个直连的 BGP 邻居关系。这样 Miami 的机器和 AS64496 就只有一跳的距离。所以 AS64496 会把请求路由到最近的 Miami 的服务器上去。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.cloudflare.com/dnssec-an-introduction/" target="_blank" rel="noopener">DNSSEC: An Introduction</a></p><p><a href="http://dyn.com/blog/understanding-dnssec/" target="_blank" rel="noopener">Understanding DNSSEC</a></p><p><a href="http://users.isc.org/~jreed/dnssec-guide/dnssec-guide.html" target="_blank" rel="noopener">BIND DNSSEC Guide</a></p><p><a href="https://www.wikiwand.com/en/List_of_DNS_record_types" target="_blank" rel="noopener">List of DNS record types</a></p><p><a href="https://technet.microsoft.com/en-us/library/cc958958.aspx" target="_blank" rel="noopener">Resource Record Types</a></p><p><a href="https://blog.cloudflare.com/a-brief-anycast-primer/" target="_blank" rel="noopener">A Brief Primer on Anycast</a></p><p><a href="http://ddiguru.com/blog/118-introduction-to-anycast-dns" target="_blank" rel="noopener">Anycast DNS - Part 1, Overview</a></p><p><a href="https://www.pacnog.org/pacnog6/IXP/Anycast-v10.pdf" target="_blank" rel="noopener">Best Practices in<br>IPv4 Anycast Routing</a></p><p><a href="https://labs.opendns.com/2013/01/10/high-availability-with-anycast-routing/" target="_blank" rel="noopener">How OpenDNS achieves high availability with Anycast routing</a></p><p><a href="http://www.ccietea.com/" target="_blank" rel="noopener">http://www.ccietea.com/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;DNS&quot;&gt;&lt;a href=&quot;#DNS&quot; class=&quot;headerlink&quot; title=&quot;DNS&quot;&gt;&lt;/a&gt;DNS&lt;/h2&gt;&lt;p&gt;本文属于 DNS 相关的进阶文章，需要读者对 DNS 的基础有所了解。基础文章可以看看&lt;a href=&quot;http://selfboo
      
    
    </summary>
    
    
    
      <category term="dns" scheme="https://0x01.io/tags/dns/"/>
    
      <category term="dnssec" scheme="https://0x01.io/tags/dnssec/"/>
    
      <category term="anycast" scheme="https://0x01.io/tags/anycast/"/>
    
      <category term="bgp" scheme="https://0x01.io/tags/bgp/"/>
    
      <category term="计算机网络" scheme="https://0x01.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>华硕AC66U入手折腾记录</title>
    <link href="https://0x01.io/2015/11/07/%E5%8D%8E%E7%A1%95AC66U%E5%85%A5%E6%89%8B%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/"/>
    <id>https://0x01.io/2015/11/07/%E5%8D%8E%E7%A1%95AC66U%E5%85%A5%E6%89%8B%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/</id>
    <published>2015-11-07T11:05:07.000Z</published>
    <updated>2020-05-28T04:41:33.625Z</updated>
    
    <content type="html"><![CDATA[<p>吃饱了撑得，想重新买个路由器。个人其实需求不大，支持 2.4/5 GHz，802.11ac，千兆之类的就行了。本来想买个好看的，最喜欢 Google 的 Onhub，但是在国内用，实在是有点蛋疼。其他也没找到颜值能和 Onhub 一拼的。只能退而求其次了。刚好看到京东上，现在华硕 AC66U 只要 599，比上半年降了非常多，于是就入手了。</p><h2 id="开箱"><a href="#开箱" class="headerlink" title="开箱"></a>开箱</h2><p>就不贴什么开箱照了，没什么意思。网上搜搜一大片。</p><h2 id="翻墙"><a href="#翻墙" class="headerlink" title="翻墙"></a>翻墙</h2><p>入手之后，就刷了网上大神集成 Shadowsocks 的梅林固件。详情可见<a href="http://www.chiphell.com/thread-1243565-1-1.html" target="_blank" rel="noopener">这里</a>。</p><p>要配置 Shadowsocks 非常简单，先在系统设置里开启 JFFS2。然后在 Tools 里面，选用智能模式，下面填上 Shadowsocks 的帐号就行。由于固件的问题，shadowsocks 的服务器地址不能使用域名，只能填 IP。应用一下设置，之后就可以愉快的翻墙了。</p><p>简单的做一些说明。代理模式就是在服务器端启动 socks v5 的代理和 HTTP 代理。需要客户端把自己的代理指向这里。HTTP 代理主要的用途是给家里面的 PS4 之类的设备翻墙使用。智能模式就是国外的地址一律走翻墙线路。白名单模式就是指定域名走翻墙线路。</p><p>由于我的 shadowsocks 线路是香港的，网络比较好，所以我用了智能模式。感觉很不错。但是有个问题，我的 telegram 客户端没有走翻墙线路。因为 Telegram 是直接使用 IP 直连的，没有经过域名的国内外判断。所以我还得手工解决这个问题。</p><p>先开启路由器的 SSH 之后，查看一下 iptables。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">maemual@RT-AC66U-3280:&#x2F;tmp&#x2F;home&#x2F;root# iptables -t nat -L</span><br><span class="line">Chain PREROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">VSERVER    all  --  anywhere             192.168.1.5</span><br><span class="line">REDIRECT   tcp  --  anywhere             anywhere            set goss dst redir ports 3333</span><br><span class="line">REDIRECT   tcp  --  anywhere             91.108.56.0&#x2F;22      redir ports 3333</span><br><span class="line">REDIRECT   tcp  --  anywhere             91.108.4.0&#x2F;22       redir ports 3333</span><br><span class="line">REDIRECT   tcp  --  anywhere             109.239.140.0&#x2F;24    redir ports 3333</span><br><span class="line">REDIRECT   tcp  --  anywhere             149.154.160.0&#x2F;20    redir ports 3333</span><br></pre></td></tr></table></figure><p>其中<code>PREROUTING</code>链的第二条，就是指名 goss 这个 ipset 里面的全部走本地的<code>ss-redir</code>线路。这里为了让 Telegram 翻墙，我们手工加了后面四条规则。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -p tcp -d 91.108.56.0&#x2F;22 -j REDIRECT --to-ports 3333</span><br><span class="line">iptables -t nat -A PREROUTING -p tcp -d 91.108.4.0&#x2F;22 -j REDIRECT --to-ports 3333</span><br><span class="line">iptables -t nat -A PREROUTING -p tcp -d 109.239.140.0&#x2F;24 -j REDIRECT --to-ports 3333</span><br><span class="line">iptables -t nat -A PREROUTING -p tcp -d 149.154.160.0&#x2F;20 -j REDIRECT --to-ports 3333</span><br></pre></td></tr></table></figure><p>但是手工加的规则，路由器一旦重启就会没了，所以我们写个脚本，让启动自动执行。根据梅林固件的<a href="https://github.com/RMerl/asuswrt-merlin/wiki/User-scripts" target="_blank" rel="noopener">官方说明</a>，只有在<code>/jffs/scripts/</code>下面的，指定的几个名字的脚本会被执行。不同名字的脚本会在不同的时候被执行。这里我们需要加的是 NAT 规则，所以建立一个脚本<code>nat-start</code>，把命令放进去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line">iptables -t nat -A PREROUTING -p tcp -d 91.108.56.0&#x2F;22 -j REDIRECT --to-ports 3333</span><br><span class="line">iptables -t nat -A PREROUTING -p tcp -d 91.108.4.0&#x2F;22 -j REDIRECT --to-ports 3333</span><br><span class="line">iptables -t nat -A PREROUTING -p tcp -d 109.239.140.0&#x2F;24 -j REDIRECT --to-ports 3333</span><br><span class="line">iptables -t nat -A PREROUTING -p tcp -d 149.154.160.0&#x2F;20 -j REDIRECT --to-ports 3333</span><br></pre></td></tr></table></figure><p>别忘了<code>chmod a+rx /jffs/scripts/*</code>，设置一下脚本可执行的权限。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;吃饱了撑得，想重新买个路由器。个人其实需求不大，支持 2.4/5 GHz，802.11ac，千兆之类的就行了。本来想买个好看的，最喜欢 Google 的 Onhub，但是在国内用，实在是有点蛋疼。其他也没找到颜值能和 Onhub 一拼的。只能退而求其次了。刚好看到京东上，现
      
    
    </summary>
    
    
    
      <category term="路由器" scheme="https://0x01.io/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"/>
    
      <category term="华硕AC66U" scheme="https://0x01.io/tags/%E5%8D%8E%E7%A1%95AC66U/"/>
    
      <category term="翻墙" scheme="https://0x01.io/tags/%E7%BF%BB%E5%A2%99/"/>
    
      <category term="shadowsocks" scheme="https://0x01.io/tags/shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>代码整洁之道（4）：格式</title>
    <link href="https://0x01.io/2015/08/31/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%EF%BC%884%EF%BC%89%EF%BC%9A%E6%A0%BC%E5%BC%8F/"/>
    <id>https://0x01.io/2015/08/31/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%EF%BC%884%EF%BC%89%EF%BC%9A%E6%A0%BC%E5%BC%8F/</id>
    <published>2015-08-31T19:57:32.000Z</published>
    <updated>2020-05-28T04:41:33.625Z</updated>
    
    <content type="html"><![CDATA[<p>你应该选用一套管理代码格式的简单规则，然后贯彻这些规则。如果在团队工作，则团队应该一致同意采用一套简单的格式规则，所有成员都要遵从。</p><h3 id="格式的目的"><a href="#格式的目的" class="headerlink" title="格式的目的"></a>格式的目的</h3><p>可读性比可用性更重要。</p><h3 id="垂直格式"><a href="#垂直格式" class="headerlink" title="垂直格式"></a>垂直格式</h3><p>短文件通常比长文件易于理解。</p><p>文件名应当简单且一目了然。</p><p>垂直方向上，每组代码行组成的思路，用空白行间隔开。</p><p>紧密相关的代码在垂直方向上也应该靠近。</p><p>自上至下展示函数的调用顺序。</p><h3 id="横向格式"><a href="#横向格式" class="headerlink" title="横向格式"></a>横向格式</h3><p>横向80字符较佳，不反对到达100字符或者120字符。不要再多。</p><p>注意缩进。</p><h3 id="团队规则"><a href="#团队规则" class="headerlink" title="团队规则"></a>团队规则</h3><p>严格遵循团队制定的规则。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;你应该选用一套管理代码格式的简单规则，然后贯彻这些规则。如果在团队工作，则团队应该一致同意采用一套简单的格式规则，所有成员都要遵从。&lt;/p&gt;
&lt;h3 id=&quot;格式的目的&quot;&gt;&lt;a href=&quot;#格式的目的&quot; class=&quot;headerlink&quot; title=&quot;格式的目的&quot;&gt;&lt;
      
    
    </summary>
    
    
    
      <category term="读书笔记" scheme="https://0x01.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="代码整洁之道" scheme="https://0x01.io/tags/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/"/>
    
      <category term="软件工程" scheme="https://0x01.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>代码整洁之道（3）：注释</title>
    <link href="https://0x01.io/2015/08/30/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%EF%BC%883%EF%BC%89%EF%BC%9A%E6%B3%A8%E9%87%8A/"/>
    <id>https://0x01.io/2015/08/30/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%EF%BC%883%EF%BC%89%EF%BC%9A%E6%B3%A8%E9%87%8A/</id>
    <published>2015-08-30T22:19:12.000Z</published>
    <updated>2020-05-28T04:41:33.625Z</updated>
    
    <content type="html"><![CDATA[<p>注释的恰当用法是弥补我们在用代码表达意图时遭遇的失败。</p><h3 id="注释不能美化糟糕的代码"><a href="#注释不能美化糟糕的代码" class="headerlink" title="注释不能美化糟糕的代码"></a>注释不能美化糟糕的代码</h3><p>带有少量注释的简洁而有表达力的代码，要比带有大量注释的零碎而复杂的代码像样的多。与其花时间编写解释你搞出来的糟糕的代码的注释，不如花时间清洁那堆糟糕的代码。</p><h3 id="用代码来阐述"><a href="#用代码来阐述" class="headerlink" title="用代码来阐述"></a>用代码来阐述</h3><h3 id="好注释"><a href="#好注释" class="headerlink" title="好注释"></a>好注释</h3><p>法律信息。如版权及著作权声明。</p><p>提供信息的注释。更好的方式是尽量利用函数名称传达信息。</p><p>警示信息。</p><p>TODO 注释。</p><p>公共 API 中的 Javadoc。</p><h3 id="坏注释"><a href="#坏注释" class="headerlink" title="坏注释"></a>坏注释</h3><p>喃喃自语。</p><p>多余的注释。相对于代码，并没有提供更多的信息。</p><p>误导性注释。</p><p>循规式注释。不是每个函数、每个变量都要有注释。</p><p>日志式注释。在有了版本控制系统的情况下，这种注释就是废话。</p><p>废话注释。</p><p>能用函数或变量时就不要用注释。</p><p>归属与署名是不必要的。版本控制系统全部记着呢。</p><p>注释掉的代码。千万不要这么干！</p><p>HTML 注释。不要这么写。不够易读。</p><p>信息过多。不要说多余的东西。</p><p>为只做一件事的短函数选个好名字，通常比函数头写注释要好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;注释的恰当用法是弥补我们在用代码表达意图时遭遇的失败。&lt;/p&gt;
&lt;h3 id=&quot;注释不能美化糟糕的代码&quot;&gt;&lt;a href=&quot;#注释不能美化糟糕的代码&quot; class=&quot;headerlink&quot; title=&quot;注释不能美化糟糕的代码&quot;&gt;&lt;/a&gt;注释不能美化糟糕的代码&lt;/h3&gt;&lt;p
      
    
    </summary>
    
    
    
      <category term="读书笔记" scheme="https://0x01.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="代码整洁之道" scheme="https://0x01.io/tags/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/"/>
    
      <category term="软件工程" scheme="https://0x01.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
</feed>
