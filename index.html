<!DOCTYPE html>
<html lang="zh-cn">
  <head><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="Go home or stand up, it's your fucking choice"/><meta name="google-site-verification" content="1XE4HjcRwxfqFivnUCvu3UNFTTG4dg7dvjgCPwcrxGg" /><link rel="alternate" href="/atom.xml" title="0x01"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0" />
<link rel="canonical" href="https://0x01.io/"/>

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0" />

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-74494566-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-74494566-1');
</script><script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":false};
</script>

    <title>0x01</title>
  <meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="0x01" type="application/atom+xml">
</head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">0x01</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">首页
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">归档
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">0x01</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            首页
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            归档
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><section id="posts" class="posts"><article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2020/05/28/%E3%80%8AThe-Effective-Engineer%E3%80%8B%E8%AF%BB%E4%B9%A6%E6%91%98%E8%A6%81/">《The Effective Engineer》读书摘要</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-05-28
        </span></div>
    </header>

    <div class="post-content"><p>高效的工程师是那些被认为可以把事情搞定的人。同时，是可以高效率的把事情搞定的人。</p>
<p>高效工程师聚焦在价值和影响力上。</p>
<h2 id="Part-1-Adopt-the-Right-Mindsets"><a href="#Part-1-Adopt-the-Right-Mindsets" class="headerlink" title="Part 1: Adopt the Right Mindsets"></a>Part 1: Adopt the Right Mindsets</h2><h3 id="Focus-on-High-Leverage-Activities"><a href="#Focus-on-High-Leverage-Activities" class="headerlink" title="Focus on High-Leverage Activities"></a>Focus on High-Leverage Activities</h3><h4 id="Use-Leverage-as-Your-Yardstick-for-Effectiveness"><a href="#Use-Leverage-as-Your-Yardstick-for-Effectiveness" class="headerlink" title="Use Leverage as Your Yardstick for Effectiveness"></a>Use Leverage as Your Yardstick for Effectiveness</h4><p>杠杆率 = 产出 / 时间</p>
<p>简单的说就是 ROI，投入产出比。</p>
<p>时间是最宝贵的资源。</p>
          <div class="read-more">
            <a href="/2020/05/28/%E3%80%8AThe-Effective-Engineer%E3%80%8B%E8%AF%BB%E4%B9%A6%E6%91%98%E8%A6%81/" class="read-more-link">阅读更多</a>
          </div>
        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2020/05/15/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93%EF%BC%9A%E9%80%9A%E5%BE%80%E5%8A%A1%E5%AE%9E%E7%9A%84%E6%9C%80%E9%AB%98%E5%A2%83%E7%95%8C%E3%80%8B%E8%AF%BB%E4%B9%A6%E6%91%98%E8%A6%81/">《程序员修炼之道：通往务实的最高境界》读书摘要</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-05-15
        </span></div>
    </header>

    <div class="post-content"><h2 id="务实的哲学"><a href="#务实的哲学" class="headerlink" title="务实的哲学"></a>务实的哲学</h2><p>1、人生是你的</p>
<p>你有权选择<br>你可以去改变组织，或者让自己换一个组织<br>这个行业给了你一系列非凡的机遇。积极主动点，掌握这些机遇</p>
<p>2、我的源码被猫吃了</p>
<p>提供选择，别找借口</p>
<p>不要说搞不定</p>
<p>3、软件的熵</p>
<p>不要放任破窗（糟糕的设计、错误的决定、低劣的代码）</p>
<p>漠视会加速腐烂的过程</p>
<p>不要只是因为一些东西非常危急，就去造成附带损伤。破窗一扇都嫌太多。</p>
          <div class="read-more">
            <a href="/2020/05/15/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93%EF%BC%9A%E9%80%9A%E5%BE%80%E5%8A%A1%E5%AE%9E%E7%9A%84%E6%9C%80%E9%AB%98%E5%A2%83%E7%95%8C%E3%80%8B%E8%AF%BB%E4%B9%A6%E6%91%98%E8%A6%81/" class="read-more-link">阅读更多</a>
          </div>
        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2020/05/07/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93%EF%BC%9A%E4%BB%8E%E5%B0%8F%E5%B7%A5%E5%88%B0%E4%B8%93%E5%AE%B6%E3%80%8B%E8%AF%BB%E4%B9%A6%E6%91%98%E8%A6%81/">《程序员修炼之道：从小工到专家》读书摘要</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-05-07
        </span></div>
    </header>

    <div class="post-content"><h2 id="注重实效的哲学"><a href="#注重实效的哲学" class="headerlink" title="注重实效的哲学"></a>注重实效的哲学</h2><p>1、我的源码让猫吃了<br>要为自己的项目负责，不要找借口，而是要找选择，找解决方案</p>
<p>2、软件的熵<br>破窗理论<br>不要容忍“破窗户”（低劣的设计、错误决策、糟糕代码）<br>一个干净整洁没有破窗的项目，其他人也不忍心第一个破坏它。但是一旦有破窗，其他人也就不在乎了，破窗越来越多。</p>
<p>3、石头汤与煮青蛙<br>做变化的催化剂<br>遇到问题的时候，尽管会面临其他人或者团队的无法支持。但是主动的去做，去拿出一个你可以拿出的可用的原型。这个时候，相关的人和团队就会发现，自己向上面添加东西，就会变得更好。<br>记住大图景。避免温水煮青蛙。</p>
          <div class="read-more">
            <a href="/2020/05/07/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93%EF%BC%9A%E4%BB%8E%E5%B0%8F%E5%B7%A5%E5%88%B0%E4%B8%93%E5%AE%B6%E3%80%8B%E8%AF%BB%E4%B9%A6%E6%91%98%E8%A6%81/" class="read-more-link">阅读更多</a>
          </div>
        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2020/02/16/x86-%E8%BD%AF%E8%B7%AF%E7%94%B1%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86%E6%9E%84%E5%BB%BA%E6%96%B9%E6%A1%88v2020-02/">x86 软路由透明代理构建方案v2020.02</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-02-16
        </span></div>
    </header>

    <div class="post-content"><p>2017 年的时候写过关于 <a href="/2017/04/01/x86-%E8%BD%AF%E8%B7%AF%E7%94%B1%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86%E6%9E%84%E5%BB%BA%E6%96%B9%E6%A1%88/" title="x86 软路由透明代理构建方案">x86 软路由透明代理构建方案</a>，当时的方案是基于 overture + redsocks + shadowsocks 做的。当时用的还挺好的。</p>
<p>但是随着时间的推移，整个社区在变化，方案也在变化。主要遇到的几个想要迁移修改的想法，一个是 redsocks 比较老，bug 多，不怎么稳定，而且不维护了。虽然有人自己改了 redsocks2 的方案，但也不那么完美吧。二个是 shadowsocks 的问题，这个众所周知了，就不描述背景了。三个是 clash 的崛起，确实挺好用，主要是一体化解决问题，还有节点维护管理能力。所以起了换 clash 的想法。</p>
<p>所以，目前新的方案是 overture + clash。其实 clash 自带 dns server，但是我觉得不够稳，也不够好用，还是继续用了 overture。部署新方案的过程中，也踩了几个坑，下面主要是想记录一下这几个坑。</p>
          <div class="read-more">
            <a href="/2020/02/16/x86-%E8%BD%AF%E8%B7%AF%E7%94%B1%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86%E6%9E%84%E5%BB%BA%E6%96%B9%E6%A1%88v2020-02/" class="read-more-link">阅读更多</a>
          </div>
        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2018/03/29/Pillow%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%E4%B9%8B%E5%9B%BE%E7%89%87%E6%B0%B4%E5%8D%B0/">Pillow踩坑记录之图片水印</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-03-29
        </span></div>
    </header>

    <div class="post-content"><p>好久没写博客了。最近在做图片水印功能，本来觉得难度不大，照着 Pillow 文档随便搞搞就行了。没想到设计师验收的时候发现一堆坑。也许是学艺不精，没有仔细研究过 Pillow，只是随便看看文档做的，可能是我用的姿势不对才导致一堆坑。</p>
<p>基本需求是：</p>
<ol>
<li>前面一个品牌 logo</li>
<li>后面一个 @用户名，用思源黑体常规字重的字体</li>
<li>有投影效果</li>
<li>整体大小和图片宽度成比例</li>
</ol>
<p>首先去 Pillow 文档里找了个 <a href="http://pillow.readthedocs.io/en/latest/reference/ImageDraw.html#example-draw-partial-opacity-text" target="_blank" rel="noopener">example</a></p>
<p>在网上查一些 blog 也都是这么写的，于是就照着写了一个基本的。</p>
          <div class="read-more">
            <a href="/2018/03/29/Pillow%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%E4%B9%8B%E5%9B%BE%E7%89%87%E6%B0%B4%E5%8D%B0/" class="read-more-link">阅读更多</a>
          </div>
        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2017/04/01/x86-%E8%BD%AF%E8%B7%AF%E7%94%B1%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86%E6%9E%84%E5%BB%BA%E6%96%B9%E6%A1%88/">x86 软路由透明代理构建方案</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-04-01
        </span></div>
    </header>

    <div class="post-content"><h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><p>网络配置：<br>    双网卡 + NAT（iptable）+ DHCP<br>DNS 解析防污染：<br>    <a href="https://github.com/shawn1m/overture" target="_blank" rel="noopener">overture</a>（解析）+ dnsmasq（缓存）<br>代理：<br>    shadowsocks（普通 Python 版即可）+ redsocks<br>透明代理：<br>    iptable + ipset（国内 IP 段）</p>
          <div class="read-more">
            <a href="/2017/04/01/x86-%E8%BD%AF%E8%B7%AF%E7%94%B1%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86%E6%9E%84%E5%BB%BA%E6%96%B9%E6%A1%88/" class="read-more-link">阅读更多</a>
          </div>
        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2016/03/21/Crypto101-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%888%EF%BC%89/">Crypto101 阅读笔记（8）</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-03-21
        </span></div>
    </header>

    <div class="post-content"><h2 id="密钥衍生函数"><a href="#密钥衍生函数" class="headerlink" title="密钥衍生函数"></a>密钥衍生函数</h2><p>密钥衍生函数（Key derivation function，KDF）通过接收一个密文，和一个可选的 salt 参数，生成另外的密文，也就是 key。</p>
<p>KDF 目前经常用户密码的存储方案。KDF 与普通的哈希加盐的密码存储方案相比，区别在于 KDF 通常会有一个很多次的迭代过程，尽可能的增加计算的时间消耗，以抵挡暴力破解。目前常用的 KDF 包括 PBKDF2、bcrypt、scrypt。优先选用 scrypt 和 bcrypt，如果没有这两个，PBKDF2 也是可以的。</p>
<h3 id="bcrypt"><a href="#bcrypt" class="headerlink" title="bcrypt"></a>bcrypt</h3><p>目前业界最常用的是 bcrypt。常用模式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> bcrypt</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>password = <span class="string">b"super secret password"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bcrypt.hashpw(password, bcrypt.gensalt(<span class="number">10</span>))</span><br><span class="line"><span class="string">'$2b$10$jN0BGbH1W/50V1mW/cLWeewfmp3d0zbnenrlDgii2M6nnFKfM5USC'</span></span><br></pre></td></tr></table></figure>

<p>生成的 hash 串，开头的 <code>$2b$</code> 是标准前缀，还有 <code>$2a$</code>、<code>$2y$</code> 等，起到类似于版本号的作用。目前的默认前缀是 <code>$2b$</code>。紧接着的 10 表示 2^10 次循环迭代。接着的 <code>jN0BGbH1W/50V1mW/cLWee</code> 128 bit，经过 base64 编码成 22 个字符，代表的是随机的 salt。随后的 <code>wfmp3d0zbnenrlDgii2M6nnFKfM5USC</code> 184 bit，base64 编码成 31 个字符，是密码的哈希。</p>
<p>之所以不使用常见的 MD5、SHA1、SHA256 之类的 hash 算法是因为常用的 hash 无法对抗暴力破解。在我的笔记本上，一个如上文的代码，当指数是 10 的时候，计算一次 bcrypt 大约花费 80 毫秒，指数是 12 的时候，花费 290 毫秒，指数是 14 的时候，花费 1.2 秒。与此相应的是，一次 md5 计算只花费了 30 微秒。</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2016/03/17/Crypto101-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%887%EF%BC%89/">Crypto101 阅读笔记（7）</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-03-17
        </span></div>
    </header>

    <div class="post-content"><h2 id="签名算法"><a href="#签名算法" class="headerlink" title="签名算法"></a>签名算法</h2><p>签名算法（Signature）是基于非对称加密的一种消息验证机制。一个数字签名用于证明其消息的可靠性真实性。一个合法的数字签名，可以让接收者有理由相信，这条消息是由一个已知的发送者创建的，并且这个发送者不能否认曾经发送这个消息，并且这个消息在传输过程中没有被篡改过。</p>
<p>常见的应用场景如软件包的签名。软件发布者在发布软件的同时会签署一个数字签名，这样使用软件的人就可以确认这个软件的真实性、可靠性。</p>
<p>签名算法的工作方式十分简单，对于一段需要签名的消息，首先使用某种数字摘要算法，即哈希算法算出摘要，然后使用非对称加密算法的密钥对消息的摘要进行加密。这个加密后的数据就是这段消息的数字签名。当接收方接收到消息之后，首先同样经过哈希算出摘要，然后使用数字签名的非对称加密算法的公钥，解开签名，然后比对两个哈希，即可得知是否是合法的。</p>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>常用的签名算法有基于 RSA 系列的 RSA-PCKS#1 v1.5 和 RSA-PSS，和美国联邦标准的 DSA 及其衍生算法 ECDSA。其中 RSA-PCKS#1 v1.5 和 DSA 都比较老旧，不推荐使用。最推荐使用椭圆曲线数学体系的 ECDSA，其次是 RSA-PSS。</p>
<h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>数字证书是签名算法和非对称加密的一种应用。</p>
<p>在一个通信过程中，为了证明自己的身份，最好的方式是提供自己的数字证书来证明。但是仅仅传输一个证书，还不足以证明，因为在传输过程中，这个证书也可能被中间人篡改、替换。所以需要引入一个第三方的权威机构 CA，来证明自己的身份，就如同现实中的公证处一般。</p>
<p>具体操作过程就是自己将一些证明信息和公钥发送给 CA，CA 经过一定的审核之后，计算出这段信息的数字签名。也就是通过特定的 Hash 算法算出摘要，然后用 CA 的私钥进行加密。这就是一个数字签名。服务端只需要把这个数字签名和自己的证书一起发给客户端。客户端接收到之后，拿到 CA 的公钥，解出信息的摘要，然后自己用相同的 Hash 算法计算摘要，比对两个摘要，如果相同，则说明验证通过。</p>
<p>更加详细的讲解可以参看<a href="https://segmentfault.com/a/1190000004199917#articleHeader4" target="_blank" rel="noopener">这篇文章</a></p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2016/03/16/Crypto101-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89/">Crypto101 阅读笔记（6）</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-03-16
        </span></div>
    </header>

    <div class="post-content"><h2 id="信息认证码"><a href="#信息认证码" class="headerlink" title="信息认证码"></a>信息认证码</h2><p>信息认证码（message authentication code，MAC），是一段比较短的比特数据，用来检查一段信息、消息的可靠性和完整性，也被称为 tag。一个 MAC 算法接收一段任意长度的消息和一个固定长度的密钥 key，产生 tag 标记。一个 MAC 算法也有一个对应的校验算法，通过接收消息、key 和 tag，告诉是否合法。</p>
<p>如果只是需要确定一段特定消息的可靠性和完整性，可以使用签名算法，这个在后面会介绍。目前可以简单的认为签名算法通常用在非对称加密中，这里的 MAC 通常用于对称加密。</p>
<p>如果只需要检验一段消息的完整性，那么使用 CRC 之类的校验码或者 SHA 之类的哈希函数，都可以做到。但是为了保证可靠性，当有人攻击的时候，如果消息被篡改，那么攻击这可以重新计算校验码或者哈希。所以 MAC 类方法都需要有一个别人都不知道的 key。</p>
<h3 id="MAC-Encrypt"><a href="#MAC-Encrypt" class="headerlink" title="MAC Encrypt"></a>MAC Encrypt</h3><p>MAC 和 Encrypt 有三种结合使用的方式。</p>
<ol>
<li>Encrypt-then-MAC：$ C = E(K_C, P), t = MAC(K_M, C)$。先将原文加密，然后计算密文的 MAC。然后把 C 和 t 一块发送出去。</li>
<li>MAC-then-Encrypt：$ t = MAC(K_M, P), C = E(K_C, P || t)$。先计算原文的 MAC，然后把原文和计算出来的 tag 和在一块，进行加密。最后只需要发送加密后的密文即可。</li>
<li>Encrypt-and-MAC：$ C = E(K_C, P), t = MAC(K_M, P) $ 分别计算密文和 tag，分别把密文和 tag 发送出去。</li>
</ol>
<p>总得说来，更推荐使用 Encrypt-then-MAC，优点在于收到 C 和 t 之后，可以先检验 t，如果不正确，就不用对 C 进行解密了。IPSec 就使用这个方式。MAC-then-Encrypt 也可以使用，但是收到密文之后，必须先全部解密出来之后，才能校验消息是否完整。TLS 早期使用这种方式。Encrypt-and-MAC 最差，通过 t 就可以暴露出原文的一些特征。同样的原文会得到同样的 t。SSH 使用这种方式。</p>
<h3 id="HMAC"><a href="#HMAC" class="headerlink" title="HMAC"></a>HMAC</h3><p>HMAC 是目前最常用，也是目前比较安全的一种 MAC 算法。他底层的哈希函数要求很低，哪怕是目前不是特别安全的 MD5 或者 SHA-0 都可以。HMAC 的工作示意如下图：</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/7f/SHAhmac.svg/1024px-SHAhmac.svg.png?1458141613104" alt="hmac-sha1"></p>
<p>其中 i_pad 是 0x363636…3636，一个常量，o_pad 是 0x5c5c5c…5c5c，另一个常量。</p>
<h3 id="Authenticated-encrption-modes"><a href="#Authenticated-encrption-modes" class="headerlink" title="Authenticated encrption modes"></a>Authenticated encrption modes</h3><p>在通常的密码学应用中，保密性用加密实现，消息认证用 MAC 实现。这两种算法的配合方式，引发了很多安全漏洞，上述的 3 种方法 Encrypt-then-MAC、MAC-then-Encrypt 和 Encrypt-and-MAC ，后来发现，后两者都是有安全问题的，所以，2008年起，逐渐提出了用一个算法在内部同时实现 cipher+ MAC 的想法，称为 AEAD(Authenticated encryption with additional data)。 在AEAD这种概念里，cipher + MAC 被一个 AEAD 算法替换。</p>
<h4 id="AES-GCM"><a href="#AES-GCM" class="headerlink" title="AES-GCM"></a>AES-GCM</h4><p>目前网络上最常用的 AEAD 类算法就是 AES-GCM。互联网上大部分的 HTTPS 流量都依赖于这个算法。</p>
<p>与 AES-GCM 相似的还有个 Chacha20-Poly1305 算法。但是目前最常用的还是 AES-GCM，因为在 Intel 的 CPU 中有专门优化的硬件指令，所以 AES-GCM 依然比 Chacha20-Poly1305 快很多。但是在移动端，ARM 处理器上，Chacha20-Poly1305 就比 AES-GCM 快了。</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2016/03/14/Crypto101-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89/">Crypto101 阅读笔记（5）</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-03-14
        </span></div>
    </header>

    <div class="post-content"><h2 id="Hash-函数"><a href="#Hash-函数" class="headerlink" title="Hash 函数"></a>Hash 函数</h2><p>hash 函数就是将任意长度的一个字符串映射到一个固定长度字符串的过程，也叫摘要。</p>
<p>密码学中的 hash 函数可以用来构建安全的消息认证算法、签名算法和随机数生成算法。对于密码学 hash 算法，我们希望以下三个事情是很难做的：</p>
<ol>
<li>修改一个消息却不改变哈希值；</li>
<li>对于一个给定的哈希值来构造一个消息；</li>
<li>找到两个具有相同哈希值的消息；</li>
</ol>
<p>对于第一个性质，通常就是所谓的雪崩效应。哪怕仅仅修改了原消息的一个 bit，也会导致最后的哈希摘要产生巨大的变化。</p>
<p>第二个特性就是单向性。通过消息算出哈希非常容易，但是根据哈希找出原摘要十分的困难。</p>
<p>第三个特性就要求哈希函数耐碰撞。</p>
<p>常见的 Hash 函数包括 MD5、SHA-1、SHA-2 和 SHA-3。MD5 和 SHA-1 最常见，但是已经不是那么的安全了。推荐使用 SHA-2。</p>
<h3 id="密码存储"><a href="#密码存储" class="headerlink" title="密码存储"></a>密码存储</h3><p>通常业务是不会直接把密码存储到数据库中的。一旦数据库泄露，所有用户的密码就会泄露。通常都会把用户的密码进行 Hash 之后再存储到数据库中。校验用户密码的时候只要比对 Hash 值是否相同即可。</p>
<p>但是对于仅仅将密码进行 MD5 或者 SHA-1 的一次 Hash 之后存储也是不安全的。尽管攻击者不能根据哈希值算出原密码，但是攻击者可以构造一个叫做彩虹表的结构。彩虹表中存储了大量常用字符串和其 Hash 的映射关系。那么就可以根据 Hash 值反向查找到原密码了。</p>
<p>对于彩虹表，通常采用一种叫加盐的方式。对于用户的密码，进行 Hash 之前先将其和一个随机字符串结合之后再 Hash。如果盐使用不当的话，依然无法保证安全性。比如全局使用一个固定的盐，那么彩虹表只需要根据这个固定的盐再重新算一次就好了。盐一定要保证每个密码都是随机的。</p>

        </div></article>
      <nav class="pagination"><a class="next" href="/page/2/">
        <span class="next-text">下一页</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></section></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:maemual@gmail.com" class="iconfont icon-email" title="email"></a>
        <a href="https://twitter.com/maemual" target="_blank" rel="noopener" class="iconfont icon-twitter" title="twitter"></a>
        <a href="https://github.com/maemual" target="_blank" rel="noopener" class="iconfont icon-github" title="github"></a>
        <a href="https://www.zhihu.com/people/maemual" target="_blank" rel="noopener" class="iconfont icon-zhihu" title="zhihu"></a>
        <a href="https://www.douban.com/people/maemual/" target="_blank" rel="noopener" class="iconfont icon-douban" title="douban"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even" target="_blank" rel="noopener">Even</a>
  </span>

  <span class="copyright-year">&copy;2014 - 2020<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">maemual</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>
</html>
